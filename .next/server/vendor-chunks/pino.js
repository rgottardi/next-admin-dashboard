"use strict";
/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
exports.id = "vendor-chunks/pino";
exports.ids = ["vendor-chunks/pino"];
exports.modules = {

/***/ "(ssr)/./node_modules/pino/lib/caller.js":
/*!*****************************************!*\
  !*** ./node_modules/pino/lib/caller.js ***!
  \*****************************************/
/***/ ((module) => {

eval("\nfunction noOpPrepareStackTrace(_, stack) {\n    return stack;\n}\nmodule.exports = function getCallers() {\n    const originalPrepare = Error.prepareStackTrace;\n    Error.prepareStackTrace = noOpPrepareStackTrace;\n    const stack = new Error().stack;\n    Error.prepareStackTrace = originalPrepare;\n    if (!Array.isArray(stack)) {\n        return undefined;\n    }\n    const entries = stack.slice(2);\n    const fileNames = [];\n    for (const entry of entries){\n        if (!entry) {\n            continue;\n        }\n        fileNames.push(entry.getFileName());\n    }\n    return fileNames;\n};\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvcGluby9saWIvY2FsbGVyLmpzIiwibWFwcGluZ3MiOiJBQUFBO0FBRUEsU0FBU0Esc0JBQXVCQyxDQUFDLEVBQUVDLEtBQUs7SUFDdEMsT0FBT0E7QUFDVDtBQUVBQyxPQUFPQyxPQUFPLEdBQUcsU0FBU0M7SUFDeEIsTUFBTUMsa0JBQWtCQyxNQUFNQyxpQkFBaUI7SUFDL0NELE1BQU1DLGlCQUFpQixHQUFHUjtJQUMxQixNQUFNRSxRQUFRLElBQUlLLFFBQVFMLEtBQUs7SUFDL0JLLE1BQU1DLGlCQUFpQixHQUFHRjtJQUUxQixJQUFJLENBQUNHLE1BQU1DLE9BQU8sQ0FBQ1IsUUFBUTtRQUN6QixPQUFPUztJQUNUO0lBRUEsTUFBTUMsVUFBVVYsTUFBTVcsS0FBSyxDQUFDO0lBRTVCLE1BQU1DLFlBQVksRUFBRTtJQUVwQixLQUFLLE1BQU1DLFNBQVNILFFBQVM7UUFDM0IsSUFBSSxDQUFDRyxPQUFPO1lBQ1Y7UUFDRjtRQUVBRCxVQUFVRSxJQUFJLENBQUNELE1BQU1FLFdBQVc7SUFDbEM7SUFFQSxPQUFPSDtBQUNUIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vbmV4dC1hZG1pbi1kYXNoYm9hcmQvLi9ub2RlX21vZHVsZXMvcGluby9saWIvY2FsbGVyLmpzP2M4OGUiXSwic291cmNlc0NvbnRlbnQiOlsiJ3VzZSBzdHJpY3QnXG5cbmZ1bmN0aW9uIG5vT3BQcmVwYXJlU3RhY2tUcmFjZSAoXywgc3RhY2spIHtcbiAgcmV0dXJuIHN0YWNrXG59XG5cbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gZ2V0Q2FsbGVycyAoKSB7XG4gIGNvbnN0IG9yaWdpbmFsUHJlcGFyZSA9IEVycm9yLnByZXBhcmVTdGFja1RyYWNlXG4gIEVycm9yLnByZXBhcmVTdGFja1RyYWNlID0gbm9PcFByZXBhcmVTdGFja1RyYWNlXG4gIGNvbnN0IHN0YWNrID0gbmV3IEVycm9yKCkuc3RhY2tcbiAgRXJyb3IucHJlcGFyZVN0YWNrVHJhY2UgPSBvcmlnaW5hbFByZXBhcmVcblxuICBpZiAoIUFycmF5LmlzQXJyYXkoc3RhY2spKSB7XG4gICAgcmV0dXJuIHVuZGVmaW5lZFxuICB9XG5cbiAgY29uc3QgZW50cmllcyA9IHN0YWNrLnNsaWNlKDIpXG5cbiAgY29uc3QgZmlsZU5hbWVzID0gW11cblxuICBmb3IgKGNvbnN0IGVudHJ5IG9mIGVudHJpZXMpIHtcbiAgICBpZiAoIWVudHJ5KSB7XG4gICAgICBjb250aW51ZVxuICAgIH1cblxuICAgIGZpbGVOYW1lcy5wdXNoKGVudHJ5LmdldEZpbGVOYW1lKCkpXG4gIH1cblxuICByZXR1cm4gZmlsZU5hbWVzXG59XG4iXSwibmFtZXMiOlsibm9PcFByZXBhcmVTdGFja1RyYWNlIiwiXyIsInN0YWNrIiwibW9kdWxlIiwiZXhwb3J0cyIsImdldENhbGxlcnMiLCJvcmlnaW5hbFByZXBhcmUiLCJFcnJvciIsInByZXBhcmVTdGFja1RyYWNlIiwiQXJyYXkiLCJpc0FycmF5IiwidW5kZWZpbmVkIiwiZW50cmllcyIsInNsaWNlIiwiZmlsZU5hbWVzIiwiZW50cnkiLCJwdXNoIiwiZ2V0RmlsZU5hbWUiXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/pino/lib/caller.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/pino/lib/constants.js":
/*!********************************************!*\
  !*** ./node_modules/pino/lib/constants.js ***!
  \********************************************/
/***/ ((module) => {

eval("/**\n * Represents default log level values\n *\n * @enum {number}\n */ \nconst DEFAULT_LEVELS = {\n    trace: 10,\n    debug: 20,\n    info: 30,\n    warn: 40,\n    error: 50,\n    fatal: 60\n};\n/**\n * Represents sort order direction: `ascending` or `descending`\n *\n * @enum {string}\n */ const SORTING_ORDER = {\n    ASC: \"ASC\",\n    DESC: \"DESC\"\n};\nmodule.exports = {\n    DEFAULT_LEVELS,\n    SORTING_ORDER\n};\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvcGluby9saWIvY29uc3RhbnRzLmpzIiwibWFwcGluZ3MiOiJBQUFBOzs7O0NBSUM7QUFDRCxNQUFNQSxpQkFBaUI7SUFDckJDLE9BQU87SUFDUEMsT0FBTztJQUNQQyxNQUFNO0lBQ05DLE1BQU07SUFDTkMsT0FBTztJQUNQQyxPQUFPO0FBQ1Q7QUFFQTs7OztDQUlDLEdBQ0QsTUFBTUMsZ0JBQWdCO0lBQ3BCQyxLQUFLO0lBQ0xDLE1BQU07QUFDUjtBQUVBQyxPQUFPQyxPQUFPLEdBQUc7SUFDZlg7SUFDQU87QUFDRiIsInNvdXJjZXMiOlsid2VicGFjazovL25leHQtYWRtaW4tZGFzaGJvYXJkLy4vbm9kZV9tb2R1bGVzL3Bpbm8vbGliL2NvbnN0YW50cy5qcz84M2JmIl0sInNvdXJjZXNDb250ZW50IjpbIi8qKlxuICogUmVwcmVzZW50cyBkZWZhdWx0IGxvZyBsZXZlbCB2YWx1ZXNcbiAqXG4gKiBAZW51bSB7bnVtYmVyfVxuICovXG5jb25zdCBERUZBVUxUX0xFVkVMUyA9IHtcbiAgdHJhY2U6IDEwLFxuICBkZWJ1ZzogMjAsXG4gIGluZm86IDMwLFxuICB3YXJuOiA0MCxcbiAgZXJyb3I6IDUwLFxuICBmYXRhbDogNjBcbn1cblxuLyoqXG4gKiBSZXByZXNlbnRzIHNvcnQgb3JkZXIgZGlyZWN0aW9uOiBgYXNjZW5kaW5nYCBvciBgZGVzY2VuZGluZ2BcbiAqXG4gKiBAZW51bSB7c3RyaW5nfVxuICovXG5jb25zdCBTT1JUSU5HX09SREVSID0ge1xuICBBU0M6ICdBU0MnLFxuICBERVNDOiAnREVTQydcbn1cblxubW9kdWxlLmV4cG9ydHMgPSB7XG4gIERFRkFVTFRfTEVWRUxTLFxuICBTT1JUSU5HX09SREVSXG59XG4iXSwibmFtZXMiOlsiREVGQVVMVF9MRVZFTFMiLCJ0cmFjZSIsImRlYnVnIiwiaW5mbyIsIndhcm4iLCJlcnJvciIsImZhdGFsIiwiU09SVElOR19PUkRFUiIsIkFTQyIsIkRFU0MiLCJtb2R1bGUiLCJleHBvcnRzIl0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/pino/lib/constants.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/pino/lib/levels.js":
/*!*****************************************!*\
  !*** ./node_modules/pino/lib/levels.js ***!
  \*****************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

eval("\n/* eslint no-prototype-builtins: 0 */ const { lsCacheSym, levelValSym, useOnlyCustomLevelsSym, streamSym, formattersSym, hooksSym, levelCompSym } = __webpack_require__(/*! ./symbols */ \"(ssr)/./node_modules/pino/lib/symbols.js\");\nconst { noop, genLog } = __webpack_require__(/*! ./tools */ \"(ssr)/./node_modules/pino/lib/tools.js\");\nconst { DEFAULT_LEVELS, SORTING_ORDER } = __webpack_require__(/*! ./constants */ \"(ssr)/./node_modules/pino/lib/constants.js\");\nconst levelMethods = {\n    fatal: (hook)=>{\n        const logFatal = genLog(DEFAULT_LEVELS.fatal, hook);\n        return function(...args) {\n            const stream = this[streamSym];\n            logFatal.call(this, ...args);\n            if (typeof stream.flushSync === \"function\") {\n                try {\n                    stream.flushSync();\n                } catch (e) {\n                // https://github.com/pinojs/pino/pull/740#discussion_r346788313\n                }\n            }\n        };\n    },\n    error: (hook)=>genLog(DEFAULT_LEVELS.error, hook),\n    warn: (hook)=>genLog(DEFAULT_LEVELS.warn, hook),\n    info: (hook)=>genLog(DEFAULT_LEVELS.info, hook),\n    debug: (hook)=>genLog(DEFAULT_LEVELS.debug, hook),\n    trace: (hook)=>genLog(DEFAULT_LEVELS.trace, hook)\n};\nconst nums = Object.keys(DEFAULT_LEVELS).reduce((o, k)=>{\n    o[DEFAULT_LEVELS[k]] = k;\n    return o;\n}, {});\nconst initialLsCache = Object.keys(nums).reduce((o, k)=>{\n    o[k] = '{\"level\":' + Number(k);\n    return o;\n}, {});\nfunction genLsCache(instance) {\n    const formatter = instance[formattersSym].level;\n    const { labels } = instance.levels;\n    const cache = {};\n    for(const label in labels){\n        const level = formatter(labels[label], Number(label));\n        cache[label] = JSON.stringify(level).slice(0, -1);\n    }\n    instance[lsCacheSym] = cache;\n    return instance;\n}\nfunction isStandardLevel(level, useOnlyCustomLevels) {\n    if (useOnlyCustomLevels) {\n        return false;\n    }\n    switch(level){\n        case \"fatal\":\n        case \"error\":\n        case \"warn\":\n        case \"info\":\n        case \"debug\":\n        case \"trace\":\n            return true;\n        default:\n            return false;\n    }\n}\nfunction setLevel(level) {\n    const { labels, values } = this.levels;\n    if (typeof level === \"number\") {\n        if (labels[level] === undefined) throw Error(\"unknown level value\" + level);\n        level = labels[level];\n    }\n    if (values[level] === undefined) throw Error(\"unknown level \" + level);\n    const preLevelVal = this[levelValSym];\n    const levelVal = this[levelValSym] = values[level];\n    const useOnlyCustomLevelsVal = this[useOnlyCustomLevelsSym];\n    const levelComparison = this[levelCompSym];\n    const hook = this[hooksSym].logMethod;\n    for(const key in values){\n        if (levelComparison(values[key], levelVal) === false) {\n            this[key] = noop;\n            continue;\n        }\n        this[key] = isStandardLevel(key, useOnlyCustomLevelsVal) ? levelMethods[key](hook) : genLog(values[key], hook);\n    }\n    this.emit(\"level-change\", level, levelVal, labels[preLevelVal], preLevelVal, this);\n}\nfunction getLevel(level) {\n    const { levels, levelVal } = this;\n    // protection against potential loss of Pino scope from serializers (edge case with circular refs - https://github.com/pinojs/pino/issues/833)\n    return levels && levels.labels ? levels.labels[levelVal] : \"\";\n}\nfunction isLevelEnabled(logLevel) {\n    const { values } = this.levels;\n    const logLevelVal = values[logLevel];\n    return logLevelVal !== undefined && this[levelCompSym](logLevelVal, this[levelValSym]);\n}\n/**\n * Determine if the given `current` level is enabled by comparing it\n * against the current threshold (`expected`).\n *\n * @param {SORTING_ORDER} direction comparison direction \"ASC\" or \"DESC\"\n * @param {number} current current log level number representation\n * @param {number} expected threshold value to compare with\n * @returns {boolean}\n */ function compareLevel(direction, current, expected) {\n    if (direction === SORTING_ORDER.DESC) {\n        return current <= expected;\n    }\n    return current >= expected;\n}\n/**\n * Create a level comparison function based on `levelComparison`\n * it could a default function which compares levels either in \"ascending\" or \"descending\" order or custom comparison function\n *\n * @param {SORTING_ORDER | Function} levelComparison sort levels order direction or custom comparison function\n * @returns Function\n */ function genLevelComparison(levelComparison) {\n    if (typeof levelComparison === \"string\") {\n        return compareLevel.bind(null, levelComparison);\n    }\n    return levelComparison;\n}\nfunction mappings(customLevels = null, useOnlyCustomLevels = false) {\n    const customNums = customLevels ? Object.keys(customLevels).reduce((o, k)=>{\n        o[customLevels[k]] = k;\n        return o;\n    }, {}) : null;\n    /* eslint-enable */ const labels = Object.assign(Object.create(Object.prototype, {\n        Infinity: {\n            value: \"silent\"\n        }\n    }), useOnlyCustomLevels ? null : nums, customNums);\n    const values = Object.assign(Object.create(Object.prototype, {\n        silent: {\n            value: Infinity\n        }\n    }), useOnlyCustomLevels ? null : DEFAULT_LEVELS, customLevels);\n    return {\n        labels,\n        values\n    };\n}\nfunction assertDefaultLevelFound(defaultLevel, customLevels, useOnlyCustomLevels) {\n    if (typeof defaultLevel === \"number\") {\n        const values = [].concat(Object.keys(customLevels || {}).map((key)=>customLevels[key]), useOnlyCustomLevels ? [] : Object.keys(nums).map((level)=>+level), Infinity);\n        if (!values.includes(defaultLevel)) {\n            throw Error(`default level:${defaultLevel} must be included in custom levels`);\n        }\n        return;\n    }\n    const labels = Object.assign(Object.create(Object.prototype, {\n        silent: {\n            value: Infinity\n        }\n    }), useOnlyCustomLevels ? null : DEFAULT_LEVELS, customLevels);\n    if (!(defaultLevel in labels)) {\n        throw Error(`default level:${defaultLevel} must be included in custom levels`);\n    }\n}\nfunction assertNoLevelCollisions(levels, customLevels) {\n    const { labels, values } = levels;\n    for(const k in customLevels){\n        if (k in values) {\n            throw Error(\"levels cannot be overridden\");\n        }\n        if (customLevels[k] in labels) {\n            throw Error(\"pre-existing level values cannot be used for new levels\");\n        }\n    }\n}\n/**\n * Validates whether `levelComparison` is correct\n *\n * @throws Error\n * @param {SORTING_ORDER | Function} levelComparison - value to validate\n * @returns\n */ function assertLevelComparison(levelComparison) {\n    if (typeof levelComparison === \"function\") {\n        return;\n    }\n    if (typeof levelComparison === \"string\" && Object.values(SORTING_ORDER).includes(levelComparison)) {\n        return;\n    }\n    throw new Error('Levels comparison should be one of \"ASC\", \"DESC\" or \"function\" type');\n}\nmodule.exports = {\n    initialLsCache,\n    genLsCache,\n    levelMethods,\n    getLevel,\n    setLevel,\n    isLevelEnabled,\n    mappings,\n    assertNoLevelCollisions,\n    assertDefaultLevelFound,\n    genLevelComparison,\n    assertLevelComparison\n};\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvcGluby9saWIvbGV2ZWxzLmpzIiwibWFwcGluZ3MiOiJBQUFBO0FBQ0EsbUNBQW1DLEdBQ25DLE1BQU0sRUFDSkEsVUFBVSxFQUNWQyxXQUFXLEVBQ1hDLHNCQUFzQixFQUN0QkMsU0FBUyxFQUNUQyxhQUFhLEVBQ2JDLFFBQVEsRUFDUkMsWUFBWSxFQUNiLEdBQUdDLG1CQUFPQSxDQUFDO0FBQ1osTUFBTSxFQUFFQyxJQUFJLEVBQUVDLE1BQU0sRUFBRSxHQUFHRixtQkFBT0EsQ0FBQztBQUNqQyxNQUFNLEVBQUVHLGNBQWMsRUFBRUMsYUFBYSxFQUFFLEdBQUdKLG1CQUFPQSxDQUFDO0FBRWxELE1BQU1LLGVBQWU7SUFDbkJDLE9BQU8sQ0FBQ0M7UUFDTixNQUFNQyxXQUFXTixPQUFPQyxlQUFlRyxLQUFLLEVBQUVDO1FBQzlDLE9BQU8sU0FBVSxHQUFHRSxJQUFJO1lBQ3RCLE1BQU1DLFNBQVMsSUFBSSxDQUFDZCxVQUFVO1lBQzlCWSxTQUFTRyxJQUFJLENBQUMsSUFBSSxLQUFLRjtZQUN2QixJQUFJLE9BQU9DLE9BQU9FLFNBQVMsS0FBSyxZQUFZO2dCQUMxQyxJQUFJO29CQUNGRixPQUFPRSxTQUFTO2dCQUNsQixFQUFFLE9BQU9DLEdBQUc7Z0JBQ1YsZ0VBQWdFO2dCQUNsRTtZQUNGO1FBQ0Y7SUFDRjtJQUNBQyxPQUFPLENBQUNQLE9BQVNMLE9BQU9DLGVBQWVXLEtBQUssRUFBRVA7SUFDOUNRLE1BQU0sQ0FBQ1IsT0FBU0wsT0FBT0MsZUFBZVksSUFBSSxFQUFFUjtJQUM1Q1MsTUFBTSxDQUFDVCxPQUFTTCxPQUFPQyxlQUFlYSxJQUFJLEVBQUVUO0lBQzVDVSxPQUFPLENBQUNWLE9BQVNMLE9BQU9DLGVBQWVjLEtBQUssRUFBRVY7SUFDOUNXLE9BQU8sQ0FBQ1gsT0FBU0wsT0FBT0MsZUFBZWUsS0FBSyxFQUFFWDtBQUNoRDtBQUVBLE1BQU1ZLE9BQU9DLE9BQU9DLElBQUksQ0FBQ2xCLGdCQUFnQm1CLE1BQU0s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RUEsSUFBSSxPQUFPQSxvQkFBb0IsWUFBWTNCLE9BQU9xQixNQUFNLENBQUNyQyxlQUFldUUsUUFBUSxDQUFDNUIsa0JBQWtCO1FBQ2pHO0lBQ0Y7SUFFQSxNQUFNLElBQUlKLE1BQU07QUFDbEI7QUFFQW1DLE9BQU9DLE9BQU8sR0FBRztJQUNmdEQ7SUFDQUU7SUFDQXRCO0lBQ0E4QztJQUNBWDtJQUNBWTtJQUNBVTtJQUNBYztJQUNBTDtJQUNBWDtJQUNBaUI7QUFDRiIsInNvdXJjZXMiOlsid2VicGFjazovL25leHQtYWRtaW4tZGFzaGJvYXJkLy4vbm9kZV9tb2R1bGVzL3Bpbm8vbGliL2xldmVscy5qcz81ZDU2Il0sInNvdXJjZXNDb250ZW50IjpbIid1c2Ugc3RyaWN0J1xuLyogZXNsaW50IG5vLXByb3RvdHlwZS1idWlsdGluczogMCAqL1xuY29uc3Qge1xuICBsc0NhY2hlU3ltLFxuICBsZXZlbFZhbFN5bSxcbiAgdXNlT25seUN1c3RvbUxldmVsc1N5bSxcbiAgc3RyZWFtU3ltLFxuICBmb3JtYXR0ZXJzU3ltLFxuICBob29rc1N5bSxcbiAgbGV2ZWxDb21wU3ltXG59ID0gcmVxdWlyZSgnLi9zeW1ib2xzJylcbmNvbnN0IHsgbm9vcCwgZ2VuTG9nIH0gPSByZXF1aXJlKCcuL3Rvb2xzJylcbmNvbnN0IHsgREVGQVVMVF9MRVZFTFMsIFNPUlRJTkdfT1JERVIgfSA9IHJlcXVpcmUoJy4vY29uc3RhbnRzJylcblxuY29uc3QgbGV2ZWxNZXRob2RzID0ge1xuICBmYXRhbDogKGhvb2spID0+IHtcbiAgICBjb25zdCBsb2dGYXRhbCA9IGdlbkxvZyhERUZBVUxUX0xFVkVMUy5mYXRhbCwgaG9vaylcbiAgICByZXR1cm4gZnVuY3Rpb24gKC4uLmFyZ3MpIHtcbiAgICAgIGNvbnN0IHN0cmVhbSA9IHRoaXNbc3RyZWFtU3ltXVxuICAgICAgbG9nRmF0YWwuY2FsbCh0aGlzLCAuLi5hcmdzKVxuICAgICAgaWYgKHR5cGVvZiBzdHJlYW0uZmx1c2hTeW5jID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgc3RyZWFtLmZsdXNoU3luYygpXG4gICAgICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgICAgICAvLyBodHRwczovL2dpdGh1Yi5jb20vcGlub2pzL3Bpbm8vcHVsbC83NDAjZGlzY3Vzc2lvbl9yMzQ2Nzg4MzEzXG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gIH0sXG4gIGVycm9yOiAoaG9vaykgPT4gZ2VuTG9nKERFRkFVTFRfTEVWRUxTLmVycm9yLCBob29rKSxcbiAgd2FybjogKGhvb2spID0+IGdlbkxvZyhERUZBVUxUX0xFVkVMUy53YXJuLCBob29rKSxcbiAgaW5mbzogKGhvb2spID0+IGdlbkxvZyhERUZBVUxUX0xFVkVMUy5pbmZvLCBob29rKSxcbiAgZGVidWc6IChob29rKSA9PiBnZW5Mb2coREVGQVVMVF9MRVZFTFMuZGVidWcsIGhvb2spLFxuICB0cmFjZTogKGhvb2spID0+IGdlbkxvZyhERUZBVUxUX0xFVkVMUy50cmFjZSwgaG9vaylcbn1cblxuY29uc3QgbnVtcyA9IE9iamVjdC5rZXlzKERFRkFVTFRfTEVWRUxTKS5yZWR1Y2UoKG8sIGspID0+IHtcbiAgb1tERUZBVUxUX0xFVkVMU1trXV0gPSBrXG4gIHJldHVybiBvXG59LCB7fSlcblxuY29uc3QgaW5pdGlhbExzQ2FjaGUgPSBPYmplY3Qua2V5cyhudW1zKS5yZWR1Y2UoKG8sIGspID0+IHtcbiAgb1trXSA9ICd7XCJsZXZlbFwiOicgKyBOdW1iZXIoaylcbiAgcmV0dXJuIG9cbn0sIHt9KVxuXG5mdW5jdGlvbiBnZW5Mc0NhY2hlIChpbnN0YW5jZSkge1xuICBjb25zdCBmb3JtYXR0ZXIgPSBpbnN0YW5jZVtmb3JtYXR0ZXJzU3ltXS5sZXZlbFxuICBjb25zdCB7IGxhYmVscyB9ID0gaW5zdGFuY2UubGV2ZWxzXG4gIGNvbnN0IGNhY2hlID0ge31cbiAgZm9yIChjb25zdCBsYWJlbCBpbiBsYWJlbHMpIHtcbiAgICBjb25zdCBsZXZlbCA9IGZvcm1hdHRlcihsYWJlbHNbbGFiZWxdLCBOdW1iZXIobGFiZWwpKVxuICAgIGNhY2hlW2xhYmVsXSA9IEpTT04uc3RyaW5naWZ5KGxldmVsKS5zbGljZSgwLCAtMSlcbiAgfVxuICBpbnN0YW5jZVtsc0NhY2hlU3ltXSA9IGNhY2hlXG4gIHJldHVybiBpbnN0YW5jZVxufVxuXG5mdW5jdGlvbiBpc1N0YW5kYXJkTGV2ZWwgKGxldmVsLCB1c2VPbmx5Q3VzdG9tTGV2ZWxzKSB7XG4gIGlmICh1c2VPbmx5Q3VzdG9tTGV2ZWxzKSB7XG4gICAgcmV0dXJuIGZhbHNlXG4gIH1cblxuICBzd2l0Y2ggKGxldmVsKSB7XG4gICAgY2FzZSAnZmF0YWwnOlxuICAgIGNhc2UgJ2Vycm9yJzpcbiAgICBjYXNlICd3YXJuJzpcbiAgICBjYXNlICdpbmZvJzpcbiAgICBjYXNlICdkZWJ1Zyc6XG4gICAgY2FzZSAndHJhY2UnOlxuICAgICAgcmV0dXJuIHRydWVcbiAgICBkZWZhdWx0OlxuICAgICAgcmV0dXJuIGZhbHNlXG4gIH1cbn1cblxuZnVuY3Rpb24gc2V0TGV2ZWwgKGxldmVsKSB7XG4gIGNvbnN0IHsgbGFiZWxzLCB2YWx1ZXMgfSA9IHRoaXMubGV2ZWxzXG4gIGlmICh0eXBlb2YgbGV2ZWwgPT09ICdudW1iZXInKSB7XG4gICAgaWYgKGxhYmVsc1tsZXZlbF0gPT09IHVuZGVmaW5lZCkgdGhyb3cgRXJyb3IoJ3Vua25vd24gbGV2ZWwgdmFsdWUnICsgbGV2ZWwpXG4gICAgbGV2ZWwgPSBsYWJlbHNbbGV2ZWxdXG4gIH1cbiAgaWYgKHZhbHVlc1tsZXZlbF0gPT09IHVuZGVmaW5lZCkgdGhyb3cgRXJyb3IoJ3Vua25vd24gbGV2ZWwgJyArIGxldmVsKVxuICBjb25zdCBwcmVMZXZlbFZhbCA9IHRoaXNbbGV2ZWxWYWxTeW1dXG4gIGNvbnN0IGxldmVsVmFsID0gdGhpc1tsZXZlbFZhbFN5bV0gPSB2YWx1ZXNbbGV2ZWxdXG4gIGNvbnN0IHVzZU9ubHlDdXN0b21MZXZlbHNWYWwgPSB0aGlzW3VzZU9ubHlDdXN0b21MZXZlbHNTeW1dXG4gIGNvbnN0IGxldmVsQ29tcGFyaXNvbiA9IHRoaXNbbGV2ZWxDb21wU3ltXVxuICBjb25zdCBob29rID0gdGhpc1tob29rc1N5bV0ubG9nTWV0aG9kXG5cbiAgZm9yIChjb25zdCBrZXkgaW4gdmFsdWVzKSB7XG4gICAgaWYgKGxldmVsQ29tcGFyaXNvbih2YWx1ZXNba2V5XSwgbGV2ZWxWYWwpID09PSBmYWxzZSkge1xuICAgICAgdGhpc1trZXldID0gbm9vcFxuICAgICAgY29udGludWVcbiAgICB9XG4gICAgdGhpc1trZXldID0gaXNTdGFuZGFyZExldmVsKGtleSwgdXNlT25seUN1c3RvbUxldmVsc1ZhbCkgPyBsZXZlbE1ldGhvZHNba2V5XShob29rKSA6IGdlbkxvZyh2YWx1ZXNba2V5XSwgaG9vaylcbiAgfVxuXG4gIHRoaXMuZW1pdChcbiAgICAnbGV2ZWwtY2hhbmdlJyxcbiAgICBsZXZlbCxcbiAgICBsZXZlbFZhbCxcbiAgICBsYWJlbHNbcHJlTGV2ZWxWYWxdLFxuICAgIHByZUxldmVsVmFsLFxuICAgIHRoaXNcbiAgKVxufVxuXG5mdW5jdGlvbiBnZXRMZXZlbCAobGV2ZWwpIHtcbiAgY29uc3QgeyBsZXZlbHMsIGxldmVsVmFsIH0gPSB0aGlzXG4gIC8vIHByb3RlY3Rpb24gYWdhaW5zdCBwb3RlbnRpYWwgbG9zcyBvZiBQaW5vIHNjb3BlIGZyb20gc2VyaWFsaXplcnMgKGVkZ2UgY2FzZSB3aXRoIGNpcmN1bGFyIHJlZnMgLSBodHRwczovL2dpdGh1Yi5jb20vcGlub2pzL3Bpbm8vaXNzdWVzLzgzMylcbiAgcmV0dXJuIChsZXZlbHMgJiYgbGV2ZWxzLmxhYmVscykgPyBsZXZlbHMubGFiZWxzW2xldmVsVmFsXSA6ICcnXG59XG5cbmZ1bmN0aW9uIGlzTGV2ZWxFbmFibGVkIChsb2dMZXZlbCkge1xuICBjb25zdCB7IHZhbHVlcyB9ID0gdGhpcy5sZXZlbHNcbiAgY29uc3QgbG9nTGV2ZWxWYWwgPSB2YWx1ZXNbbG9nTGV2ZWxdXG4gIHJldHVybiBsb2dMZXZlbFZhbCAhPT0gdW5kZWZpbmVkICYmIHRoaXNbbGV2ZWxDb21wU3ltXShsb2dMZXZlbFZhbCwgdGhpc1tsZXZlbFZhbFN5bV0pXG59XG5cbi8qKlxuICogRGV0ZXJtaW5lIGlmIHRoZSBnaXZlbiBgY3VycmVudGAgbGV2ZWwgaXMgZW5hYmxlZCBieSBjb21wYXJpbmcgaXRcbiAqIGFnYWluc3QgdGhlIGN1cnJlbnQgdGhyZXNob2xkIChgZXhwZWN0ZWRgKS5cbiAqXG4gKiBAcGFyYW0ge1NPUlRJTkdfT1JERVJ9IGRpcmVjdGlvbiBjb21wYXJpc29uIGRpcmVjdGlvbiBcIkFTQ1wiIG9yIFwiREVTQ1wiXG4gKiBAcGFyYW0ge251bWJlcn0gY3VycmVudCBjdXJyZW50IGxvZyBsZXZlbCBudW1iZXIgcmVwcmVzZW50YXRpb25cbiAqIEBwYXJhbSB7bnVtYmVyfSBleHBlY3RlZCB0aHJlc2hvbGQgdmFsdWUgdG8gY29tcGFyZSB3aXRoXG4gKiBAcmV0dXJucyB7Ym9vbGVhbn1cbiAqL1xuZnVuY3Rpb24gY29tcGFyZUxldmVsIChkaXJlY3Rpb24sIGN1cnJlbnQsIGV4cGVjdGVkKSB7XG4gIGlmIChkaXJlY3Rpb24gPT09IFNPUlRJTkdfT1JERVIuREVTQykge1xuICAgIHJldHVybiBjdXJyZW50IDw9IGV4cGVjdGVkXG4gIH1cblxuICByZXR1cm4gY3VycmVudCA+PSBleHBlY3RlZFxufVxuXG4vKipcbiAqIENyZWF0ZSBhIGxldmVsIGNvbXBhcmlzb24gZnVuY3Rpb24gYmFzZWQgb24gYGxldmVsQ29tcGFyaXNvbmBcbiAqIGl0IGNvdWxkIGEgZGVmYXVsdCBmdW5jdGlvbiB3aGljaCBjb21wYXJlcyBsZXZlbHMgZWl0aGVyIGluIFwiYXNjZW5kaW5nXCIgb3IgXCJkZXNjZW5kaW5nXCIgb3JkZXIgb3IgY3VzdG9tIGNvbXBhcmlzb24gZnVuY3Rpb25cbiAqXG4gKiBAcGFyYW0ge1NPUlRJTkdfT1JERVIgfCBGdW5jdGlvbn0gbGV2ZWxDb21wYXJpc29uIHNvcnQgbGV2ZWxzIG9yZGVyIGRpcmVjdGlvbiBvciBjdXN0b20gY29tcGFyaXNvbiBmdW5jdGlvblxuICogQHJldHVybnMgRnVuY3Rpb25cbiAqL1xuZnVuY3Rpb24gZ2VuTGV2ZWxDb21wYXJpc29uIChsZXZlbENvbXBhcmlzb24pIHtcbiAgaWYgKHR5cGVvZiBsZXZlbENvbXBhcmlzb24gPT09ICdzdHJpbmcnKSB7XG4gICAgcmV0dXJuIGNvbXBhcmVMZXZlbC5iaW5kKG51bGwsIGxldmVsQ29tcGFyaXNvbilcbiAgfVxuXG4gIHJldHVybiBsZXZlbENvbXBhcmlzb25cbn1cblxuZnVuY3Rpb24gbWFwcGluZ3MgKGN1c3RvbUxldmVscyA9IG51bGwsIHVzZU9ubHlDdXN0b21MZXZlbHMgPSBmYWxzZSkge1xuICBjb25zdCBjdXN0b21OdW1zID0gY3VzdG9tTGV2ZWxzXG4gICAgLyogZXNsaW50LWRpc2FibGUgKi9cbiAgICA/IE9iamVjdC5rZXlzKGN1c3RvbUxldmVscykucmVkdWNlKChvLCBrKSA9PiB7XG4gICAgICAgIG9bY3VzdG9tTGV2ZWxzW2tdXSA9IGtcbiAgICAgICAgcmV0dXJuIG9cbiAgICAgIH0sIHt9KVxuICAgIDogbnVsbFxuICAgIC8qIGVzbGludC1lbmFibGUgKi9cblxuICBjb25zdCBsYWJlbHMgPSBPYmplY3QuYXNzaWduKFxuICAgIE9iamVjdC5jcmVhdGUoT2JqZWN0LnByb3RvdHlwZSwgeyBJbmZpbml0eTogeyB2YWx1ZTogJ3NpbGVudCcgfSB9KSxcbiAgICB1c2VPbmx5Q3VzdG9tTGV2ZWxzID8gbnVsbCA6IG51bXMsXG4gICAgY3VzdG9tTnVtc1xuICApXG4gIGNvbnN0IHZhbHVlcyA9IE9iamVjdC5hc3NpZ24oXG4gICAgT2JqZWN0LmNyZWF0ZShPYmplY3QucHJvdG90eXBlLCB7IHNpbGVudDogeyB2YWx1ZTogSW5maW5pdHkgfSB9KSxcbiAgICB1c2VPbmx5Q3VzdG9tTGV2ZWxzID8gbnVsbCA6IERFRkFVTFRfTEVWRUxTLFxuICAgIGN1c3RvbUxldmVsc1xuICApXG4gIHJldHVybiB7IGxhYmVscywgdmFsdWVzIH1cbn1cblxuZnVuY3Rpb24gYXNzZXJ0RGVmYXVsdExldmVsRm91bmQgKGRlZmF1bHRMZXZlbCwgY3VzdG9tTGV2ZWxzLCB1c2VPbmx5Q3VzdG9tTGV2ZWxzKSB7XG4gIGlmICh0eXBlb2YgZGVmYXVsdExldmVsID09PSAnbnVtYmVyJykge1xuICAgIGNvbnN0IHZhbHVlcyA9IFtdLmNvbmNhdChcbiAgICAgIE9iamVjdC5rZXlzKGN1c3RvbUxldmVscyB8fCB7fSkubWFwKGtleSA9PiBjdXN0b21MZXZlbHNba2V5XSksXG4gICAgICB1c2VPbmx5Q3VzdG9tTGV2ZWxzID8gW10gOiBPYmplY3Qua2V5cyhudW1zKS5tYXAobGV2ZWwgPT4gK2xldmVsKSxcbiAgICAgIEluZmluaXR5XG4gICAgKVxuICAgIGlmICghdmFsdWVzLmluY2x1ZGVzKGRlZmF1bHRMZXZlbCkpIHtcbiAgICAgIHRocm93IEVycm9yKGBkZWZhdWx0IGxldmVsOiR7ZGVmYXVsdExldmVsfSBtdXN0IGJlIGluY2x1ZGVkIGluIGN1c3RvbSBsZXZlbHNgKVxuICAgIH1cbiAgICByZXR1cm5cbiAgfVxuXG4gIGNvbnN0IGxhYmVscyA9IE9iamVjdC5hc3NpZ24oXG4gICAgT2JqZWN0LmNyZWF0ZShPYmplY3QucHJvdG90eXBlLCB7IHNpbGVudDogeyB2YWx1ZTogSW5maW5pdHkgfSB9KSxcbiAgICB1c2VPbmx5Q3VzdG9tTGV2ZWxzID8gbnVsbCA6IERFRkFVTFRfTEVWRUxTLFxuICAgIGN1c3RvbUxldmVsc1xuICApXG4gIGlmICghKGRlZmF1bHRMZXZlbCBpbiBsYWJlbHMpKSB7XG4gICAgdGhyb3cgRXJyb3IoYGRlZmF1bHQgbGV2ZWw6JHtkZWZhdWx0TGV2ZWx9IG11c3QgYmUgaW5jbHVkZWQgaW4gY3VzdG9tIGxldmVsc2ApXG4gIH1cbn1cblxuZnVuY3Rpb24gYXNzZXJ0Tm9MZXZlbENvbGxpc2lvbnMgKGxldmVscywgY3VzdG9tTGV2ZWxzKSB7XG4gIGNvbnN0IHsgbGFiZWxzLCB2YWx1ZXMgfSA9IGxldmVsc1xuICBmb3IgKGNvbnN0IGsgaW4gY3VzdG9tTGV2ZWxzKSB7XG4gICAgaWYgKGsgaW4gdmFsdWVzKSB7XG4gICAgICB0aHJvdyBFcnJvcignbGV2ZWxzIGNhbm5vdCBiZSBvdmVycmlkZGVuJylcbiAgICB9XG4gICAgaWYgKGN1c3RvbUxldmVsc1trXSBpbiBsYWJlbHMpIHtcbiAgICAgIHRocm93IEVycm9yKCdwcmUtZXhpc3RpbmcgbGV2ZWwgdmFsdWVzIGNhbm5vdCBiZSB1c2VkIGZvciBuZXcgbGV2ZWxzJylcbiAgICB9XG4gIH1cbn1cblxuLyoqXG4gKiBWYWxpZGF0ZXMgd2hldGhlciBgbGV2ZWxDb21wYXJpc29uYCBpcyBjb3JyZWN0XG4gKlxuICogQHRocm93cyBFcnJvclxuICogQHBhcmFtIHtTT1JUSU5HX09SREVSIHwgRnVuY3Rpb259IGxldmVsQ29tcGFyaXNvbiAtIHZhbHVlIHRvIHZhbGlkYXRlXG4gKiBAcmV0dXJuc1xuICovXG5mdW5jdGlvbiBhc3NlcnRMZXZlbENvbXBhcmlzb24gKGxldmVsQ29tcGFyaXNvbikge1xuICBpZiAodHlwZW9mIGxldmVsQ29tcGFyaXNvbiA9PT0gJ2Z1bmN0aW9uJykge1xuICAgIHJldHVyblxuICB9XG5cbiAgaWYgKHR5cGVvZiBsZXZlbENvbXBhcmlzb24gPT09ICdzdHJpbmcnICYmIE9iamVjdC52YWx1ZXMoU09SVElOR19PUkRFUikuaW5jbHVkZXMobGV2ZWxDb21wYXJpc29uKSkge1xuICAgIHJldHVyblxuICB9XG5cbiAgdGhyb3cgbmV3IEVycm9yKCdMZXZlbHMgY29tcGFyaXNvbiBzaG91bGQgYmUgb25lIG9mIFwiQVNDXCIsIFwiREVTQ1wiIG9yIFwiZnVuY3Rpb25cIiB0eXBlJylcbn1cblxubW9kdWxlLmV4cG9ydHMgPSB7XG4gIGluaXRpYWxMc0NhY2hlLFxuICBnZW5Mc0NhY2hlLFxuICBsZXZlbE1ldGhvZHMsXG4gIGdldExldmVsLFxuICBzZXRMZXZlbCxcbiAgaXNMZXZlbEVuYWJsZWQsXG4gIG1hcHBpbmdzLFxuICBhc3NlcnROb0xldmVsQ29sbGlzaW9ucyxcbiAgYXNzZXJ0RGVmYXVsdExldmVsRm91bmQsXG4gIGdlbkxldmVsQ29tcGFyaXNvbixcbiAgYXNzZXJ0TGV2ZWxDb21wYXJpc29uXG59XG4iXSwibmFtZXMiOlsibHNDYWNoZVN5bSIsImxldmVsVmFsU3ltIiwidXNlT25seUN1c3RvbUxldmVsc1N5bSIsInN0cmVhbVN5bSIsImZvcm1hdHRlcnNTeW0iLCJob29rc1N5bSIsImxldmVsQ29tcFN5bSIsInJlcXVpcmUiLCJub29wIiwiZ2VuTG9nIiwiREVGQVVMVF9MRVZFTFMiLCJTT1JUSU5HX09SREVSIiwibGV2ZWxNZXRob2RzIiwiZmF0YWwiLCJob29rIiwibG9nRmF0YWwiLCJhcmdzIiwic3RyZWFtIiwiY2FsbCIsImZsdXNoU3luYyIsImUiLCJlcnJvciIsIndhcm4iLCJpbmZvIiwiZGVidWciLCJ0cmFjZSIsIm51bXMiLCJPYmplY3QiLCJrZXlzIiwicmVkdWNlIiwibyIsImsiLCJpbml0aWFsTHNDYWNoZSIsIk51bWJlciIsImdlbkxzQ2FjaGUiLCJpbnN0YW5jZSIsImZvcm1hdHRlciIsImxldmVsIiwibGFiZWxzIiwibGV2ZWxzIiwiY2FjaGUiLCJsYWJlbCIsIkpTT04iLCJzdHJpbmdpZnkiLCJzbGljZSIsImlzU3RhbmRhcmRMZXZlbCIsInVzZU9ubHlDdXN0b21MZXZlbHMiLCJzZXRMZXZlbCIsInZhbHVlcyIsInVuZGVmaW5lZCIsIkVycm9yIiwicHJlTGV2ZWxWYWwiLCJsZXZlbFZhbCIsInVzZU9ubHlDdXN0b21MZXZlbHNWYWwiLCJsZXZlbENvbXBhcmlzb24iLCJsb2dNZXRob2QiLCJrZXkiLCJlbWl0IiwiZ2V0TGV2ZWwiLCJpc0xldmVsRW5hYmxlZCIsImxvZ0xldmVsIiwibG9nTGV2ZWxWYWwiLCJjb21wYXJlTGV2ZWwiLCJkaXJlY3Rpb24iLCJjdXJyZW50IiwiZXhwZWN0ZWQiLCJERVNDIiwiZ2VuTGV2ZWxDb21wYXJpc29uIiwiYmluZCIsIm1hcHBpbmdzIiwiY3VzdG9tTGV2ZWxzIiwiY3VzdG9tTnVtcyIsImFzc2lnbiIsImNyZWF0ZSIsInByb3RvdHlwZSIsIkluZmluaXR5IiwidmFsdWUiLCJzaWxlbnQiLCJhc3NlcnREZWZhdWx0TGV2ZWxGb3VuZCIsImRlZmF1bHRMZXZlbCIsImNvbmNhdCIsIm1hcCIsImluY2x1ZGVzIiwiYXNzZXJ0Tm9MZXZlbENvbGxpc2lvbnMiLCJhc3NlcnRMZXZlbENvbXBhcmlzb24iLCJtb2R1bGUiLCJleHBvcnRzIl0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/pino/lib/levels.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/pino/lib/meta.js":
/*!***************************************!*\
  !*** ./node_modules/pino/lib/meta.js ***!
  \***************************************/
/***/ ((module) => {

eval("\nmodule.exports = {\n    version: \"9.6.0\"\n};\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvcGluby9saWIvbWV0YS5qcyIsIm1hcHBpbmdzIjoiQUFBQTtBQUVBQSxPQUFPQyxPQUFPLEdBQUc7SUFBRUMsU0FBUztBQUFRIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vbmV4dC1hZG1pbi1kYXNoYm9hcmQvLi9ub2RlX21vZHVsZXMvcGluby9saWIvbWV0YS5qcz8yMTllIl0sInNvdXJjZXNDb250ZW50IjpbIid1c2Ugc3RyaWN0J1xuXG5tb2R1bGUuZXhwb3J0cyA9IHsgdmVyc2lvbjogJzkuNi4wJyB9XG4iXSwibmFtZXMiOlsibW9kdWxlIiwiZXhwb3J0cyIsInZlcnNpb24iXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/pino/lib/meta.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/pino/lib/multistream.js":
/*!**********************************************!*\
  !*** ./node_modules/pino/lib/multistream.js ***!
  \**********************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

eval("\nconst metadata = Symbol.for(\"pino.metadata\");\nconst { DEFAULT_LEVELS } = __webpack_require__(/*! ./constants */ \"(ssr)/./node_modules/pino/lib/constants.js\");\nconst DEFAULT_INFO_LEVEL = DEFAULT_LEVELS.info;\nfunction multistream(streamsArray, opts) {\n    let counter = 0;\n    streamsArray = streamsArray || [];\n    opts = opts || {\n        dedupe: false\n    };\n    const streamLevels = Object.create(DEFAULT_LEVELS);\n    streamLevels.silent = Infinity;\n    if (opts.levels && typeof opts.levels === \"object\") {\n        Object.keys(opts.levels).forEach((i)=>{\n            streamLevels[i] = opts.levels[i];\n        });\n    }\n    const res = {\n        write,\n        add,\n        emit,\n        flushSync,\n        end,\n        minLevel: 0,\n        streams: [],\n        clone,\n        [metadata]: true,\n        streamLevels\n    };\n    if (Array.isArray(streamsArray)) {\n        streamsArray.forEach(add, res);\n    } else {\n        add.call(res, streamsArray);\n    }\n    // clean this object up\n    // or it will stay allocated forever\n    // as it is closed on the following closures\n    streamsArray = null;\n    return res;\n    // we can exit early because the streams are ordered by level\n    function write(data) {\n        let dest;\n        const level = this.lastLevel;\n        const { streams } = this;\n        // for handling situation when several streams has the same level\n        let recordedLevel = 0;\n        let stream;\n        // if dedupe set to true we send logs to the stream with the highest level\n        // therefore, we have to change sorting order\n        for(let i = initLoopVar(streams.length, opts.dedupe); checkLoopVar(i, streams.length, opts.dedupe); i = adjustLoopVar(i, opts.dedupe)){\n            dest = streams[i];\n            if (dest.level <= level) {\n                if (recordedLevel !== 0 && recordedLevel !== dest.level) {\n                    break;\n                }\n                stream = dest.stream;\n                if (stream[metadata]) {\n                    const { lastTime, lastMsg, lastObj, lastLogger } = this;\n                    stream.lastLevel = level;\n                    stream.lastTime = lastTime;\n                    stream.lastMsg = lastMsg;\n                    stream.lastObj = lastObj;\n                    stream.lastLogger = lastLogger;\n                }\n                stream.write(data);\n                if (opts.dedupe) {\n                    recordedLevel = dest.level;\n                }\n            } else if (!opts.dedupe) {\n                break;\n            }\n        }\n    }\n    function emit(...args) {\n        for (const { stream } of this.streams){\n            if (typeof stream.emit === \"function\") {\n                stream.emit(...args);\n            }\n        }\n    }\n    function flushSync() {\n        for (const { stream } of this.streams){\n            if (typeof stream.flushSync === \"function\") {\n                stream.flushSync();\n            }\n        }\n    }\n    function add(dest) {\n        if (!dest) {\n            return res;\n        }\n        // Check that dest implements either StreamEntry or DestinationStream\n        const isStream = typeof dest.write === \"function\" || dest.stream;\n        const stream_ = dest.write ? dest : dest.stream;\n        // This is necessary to provide a meaningful error message, otherwise it throws somewhere inside write()\n        if (!isStream) {\n            throw Error(\"stream object needs to implement either StreamEntry or DestinationStream interface\");\n        }\n        const { streams, streamLevels } = this;\n        let level;\n        if (typeof dest.levelVal === \"number\") {\n            level = dest.levelVal;\n        } else if (typeof dest.level === \"string\") {\n            level = streamLevels[dest.level];\n        } else if (typeof dest.level === \"number\") {\n            level = dest.level;\n        } else {\n            level = DEFAULT_INFO_LEVEL;\n        }\n        const dest_ = {\n            stream: stream_,\n            level,\n            levelVal: undefined,\n            id: counter++\n        };\n        streams.unshift(dest_);\n        streams.sort(compareByLevel);\n        this.minLevel = streams[0].level;\n        return res;\n    }\n    function end() {\n        for (const { stream } of this.streams){\n            if (typeof stream.flushSync === \"function\") {\n                stream.flushSync();\n            }\n            stream.end();\n        }\n    }\n    function clone(level) {\n        const streams = new Array(this.streams.length);\n        for(let i = 0; i < streams.length; i++){\n            streams[i] = {\n                level,\n                stream: this.streams[i].stream\n            };\n        }\n        return {\n            write,\n            add,\n            minLevel: level,\n            streams,\n            clone,\n            emit,\n            flushSync,\n            [metadata]: true\n        };\n    }\n}\nfunction compareByLevel(a, b) {\n    return a.level - b.level;\n}\nfunction initLoopVar(length, dedupe) {\n    return dedupe ? length - 1 : 0;\n}\nfunction adjustLoopVar(i, dedupe) {\n    return dedupe ? i - 1 : i + 1;\n}\nfunction checkLoopVar(i, length, dedupe) {\n    return dedupe ? i >= 0 : i < length;\n}\nmodule.exports = multistream;\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvcGluby9saWIvbXVsdGlzdHJlYW0uanMiLCJtYXBwaW5ncyI6IkFBQUE7QUFFQSxNQUFNQSxXQUFXQyxPQUFPQyxHQUFHLENBQUM7QUFDNUIsTUFBTSxFQUFFQyxjQUFjLEVBQUUsR0FBR0MsbUJBQU9BLENBQUM7QUFFbkMsTUFBTUMscUJBQXFCRixlQUFlRyxJQUFJO0FBRTlDLFNBQVNDLFlBQWFDLFlBQVksRUFBRUMsSUFBSTtJQUN0QyxJQUFJQyxVQUFVO0lBQ2RGLGVBQWVBLGdCQUFnQixFQUFFO0lBQ2pDQyxPQUFPQSxRQUFRO1FBQUVFLFFBQVE7SUFBTTtJQUUvQixNQUFNQyxlQUFlQyxPQUFPQyxNQUFNLENBQUNYO0lBQ25DUyxhQUFhRyxNQUFNLEdBQUdDO0lBQ3RCLElBQUlQLEtBQUtRLE1BQU0sSUFBSSxPQUFPUixLQUFLUSxNQUFNLEtBQUssVUFBVTtRQUNsREosT0FBT0ssSUFBSSxDQUFDVCxLQUFLUSxNQUFNLEVBQUVFLE9BQU8sQ0FBQ0MsQ0FBQUE7WUFDL0JSLFlBQVksQ0FBQ1EsRUFBRSxHQUFHWCxLQUFLUSxNQUFNLENBQUNHLEVBQUU7UUFDbEM7SUFDRjtJQUVBLE1BQU1DLE1BQU07UUFDVkM7UUFDQUM7UUFDQUM7UUFDQUM7UUFDQUM7UUFDQUMsVUFBVTtRQUNWQyxTQUFTLEVBQUU7UUFDWEM7UUFDQSxDQUFDN0IsU0FBUyxFQUFFO1FBQ1pZO0lBQ0Y7SUFFQSxJQUFJa0IsTUFBTUMsT0FBTyxDQUFDdkIsZUFBZTtRQUMvQkEsYUFBYVcsT0FBTyxDQUFDSSxLQUFLRjtJQUM1QixPQUFPO1FBQ0xFLElBQUlTLElBQUksQ0FBQ1gsS0FBS2I7SUFDaEI7SUFFQSx1QkFBdUI7SUFDdkIsb0NBQW9DO0lBQ3BDLDRDQUE0QztJQUM1Q0EsZUFBZTtJQUVmLE9BQU9hO0lBRVAsNkRBQTZEO0lBQzdELFNBQVNDLE1BQU9XLElBQUk7UUFDbEIsSUFBSUM7UUFDSixNQUFNQyxRQUFRLElBQUksQ0FBQ0MsU0FBUztRQUM1QixNQUFNLEVBQUVSLE9BQU8sRUFBRSxHQUFHLElBQUk7UUFDeEIsaUVBQWlFO1FBQ2pFLElBQUlTLGdCQUFnQjtRQUNwQixJQUFJQztRQUVKLDBFQUEwRTtRQUMxRSw2Q0FBNkM7UUFDN0MsSUFBSyxJQUFJbEIsSUFBSW1CLFlBQVlYLFFBQVFZLE1BQU0sRUFBRS9CLEtBQUtFLE1BQU0sR0FBRzhCLGFBQWFyQixHQUFHUSxRQUFRWSxNQUFNLEVBQUUvQixLQUFLRSxNQUFNLEdBQUdTLElBQUlzQixjQUFjdEIsR0FBR1gsS0FBS0UsTUFBTSxFQUFHO1lBQ3RJdUIsT0FBT04sT0FBTyxDQUFDUixFQUFFO1lBQ2pCLElBQUljLEtBQUtDLEtBQUssSUFBSUEsT0FBTztnQkFDdkIsSUFBSUUsa0JBQWtCLEtBQUtBLGtCQUFrQkgsS0FBS0MsS0FBSyxFQUFFO29CQUN2RDtnQkFDRjtnQkFDQUcsU0FBU0osS0FBS0ksTUFBTTtnQkFDcEIsSUFBSUEsTUFBTSxDQUFDdEMsU0FBUyxFQUFFO29CQUNwQixNQUFNLEVBQUUyQyxRQUFRLEVBQUVDLE9BQU8sRUFBRUMsT0FBTyxFQUFFQyxVQUFVLEVBQUUsR0FBRyxJQUFJO29CQUN2RFIsT0FBT0YsU0FBUyxHQUFHRDtvQkFDbkJHLE9BQU9LLFFBQVEsR0FBR0E7b0JBQ2xCTCxPQUFPTSxPQUFPLEdBQUdBO29CQUNqQk4sT0FBT08sT0FBTyxHQUFHQTtvQkFDakJQLE9BQU9RLFVBQVUsR0FBR0E7Z0JBQ3RCO2dCQUNBUixPQUFPaEIsS0FBSyxDQUFDVztnQkFDYixJQUFJeEIsS0FBS0UsTUFBTSxFQUFFO29CQUNmMEIsZ0JBQWdCSCxLQUFLQyxLQUFLO2dCQUM1QjtZQUNGLE9BQU8sSUFBSSxDQUFDMUIsS0FBS0UsTUFBTSxFQUFFO2dCQUN2QjtZQUNGO1FBQ0Y7SUFDRjtJQUVBLFNBQVNhLEtBQU0sR0FBR3VCLElBQUk7UUFDcEIsS0FBSyxNQUFNLEVBQUVULE1BQU0sRUFBRSxJQUFJLElBQUksQ0FBQ1YsT0FBTyxDQUFFO1lBQ3JDLElBQUksT0FBT1UsT0FBT2QsSUFBSSxLQUFLLFlBQVk7Z0JBQ3JDYyxPQUFPZCxJQUFJLElBQUl1QjtZQUNqQjtRQUNGO0lBQ0Y7SUFFQSxTQUFTdEI7UUFDUCxLQUFLLE1BQU0sRUFBRWEsTUFBTSxFQUFFLElBQUksSUFBSSxDQUFDVixPQUFPLENBQUU7WUFDckMsSUFBSSxPQUFPVSxPQUFPYixTQUFTLEtBQUssWUFBWTtnQkFDMUNhLE9BQU9iLFNBQVM7WUFDbEI7UUFDRjtJQUNGO0lBRUEsU0FBU0YsSUFBS1csSUFBSTtRQUNoQixJQUFJLENBQUNBLE1BQU07WUFDVCxPQUFPYjtRQUNUO1FBRUEscUVBQXFFO1FBQ3JFLE1BQU0yQixXQUFXLE9BQU9kLEtBQUtaLEtBQUssS0FBSyxjQUFjWSxLQUFLSSxNQUFNO1FBQ2hFLE1BQU1XLFVBQVVmLEtBQUtaLEtBQUssR0FBR1ksT0FBT0EsS0FBS0ksTUFBTTtRQUMvQyx3R0FBd0c7UUFDeEcsSUFBSSxDQUFDVSxVQUFVO1lBQ2IsTUFBTUUsTUFBTTtRQUNkO1FBRUEsTUFBTSxFQUFFdEIsT0FBTyxFQUFFaEIsWUFBWSxFQUFFLEdBQUcsSUFBSTtRQUV0QyxJQUFJdUI7UUFDSixJQUFJLE9BQU9ELEtBQUtpQixRQUFRLEtBQUssVUFBVTtZQUNyQ2hCLFFBQVFELEtBQUtpQixRQUFRO1FBQ3ZCLE9BQU8sSUFBSSxPQUFPakIsS0FBS0MsS0FBSyxLQUFLLFVBQVU7WUFDekNBLFFBQVF2QixZQUFZLENBQUNzQixLQUFLQyxLQUFLLENBQUM7UUFDbEMsT0FBTyxJQUFJLE9BQU9ELEtBQUtDLEtBQUssS0FBSyxVQUFVO1lBQ3pDQSxRQUFRRCxLQUFLQyxLQUFLO1FBQ3BCLE9BQU87WUFDTEEsUUFBUTlCO1FBQ1Y7UUFFQSxNQUFNK0MsUUFBUTtZQUNaZCxRQUFRVztZQUNSZDtZQUNBZ0IsVUFBVUU7WUFDVkMsSUFBSTVDO1FBQ047UUFFQWtCLFFBQVEyQixPQUFPLENBQUNIO1FBQ2hCeEIsUUFBUTRCLElBQUksQ0FBQ0M7UUFFYixJQUFJLENBQUM5QixRQUFRLEdBQUdDLE9BQU8sQ0FBQyxFQUFFLENBQUNPLEtBQUs7UUFFaEMsT0FBT2Q7SUFDVDtJQUVBLFNBQVNLO1FBQ1AsS0FBSyxNQUFNLEVBQUVZLE1BQU0sRUFBRSxJQUFJLElBQUksQ0FBQ1YsT0FBTyxDQUFFO1lBQ3JDLElBQUksT0FBT1UsT0FBT2IsU0FBUyxLQUFLLFlBQVk7Z0JBQzFDYSxPQUFPYixTQUFTO1lBQ2xCO1lBQ0FhLE9BQU9aLEdBQUc7UUFDWjtJQUNGO0lBRUEsU0FBU0csTUFBT00sS0FBSztRQUNuQixNQUFNUCxVQUFVLElBQUlFLE1BQU0sSUFBSSxDQUFDRixPQUFPLENBQUNZLE1BQU07UUFFN0MsSUFBSyxJQUFJcEIsSUFBSSxHQUFHQSxJQUFJUSxRQUFRWSxNQUFNLEVBQUVwQixJQUFLO1lBQ3ZDUSxPQUFPLENBQUNSLEVBQUUsR0FBRztnQkFDWGU7Z0JBQ0FHLFFBQVEsSUFBSSxDQUFDVixPQUFPLENBQUNSLEVBQUUsQ0FBQ2tCLE1BQU07WUFDaEM7UUFDRjtRQUVBLE9BQU87WUFDTGhCO1lBQ0FDO1lBQ0FJLFVBQVVRO1lBQ1ZQO1lBQ0FDO1lBQ0FMO1lBQ0FDO1lBQ0EsQ0FBQ3pCLFNBQVMsRUFBRTtRQUNkO0lBQ0Y7QUFDRjtBQUVBLFNBQVN5RCxlQUFnQkMsQ0FBQyxFQUFFQyxDQUFDO0lBQzNCLE9BQU9ELEVBQUV2QixLQUFLLEdBQUd3QixFQUFFeEIsS0FBSztBQUMxQjtBQUVBLFNBQVNJLFlBQWFDLE1BQU0sRUFBRTdCLE1BQU07SUFDbEMsT0FBT0EsU0FBUzZCLFNBQVMsSUFBSTtBQUMvQjtBQUVBLFNBQVNFLGNBQWV0QixDQUFDLEVBQUVULE1BQU07SUFDL0IsT0FBT0EsU0FBU1MsSUFBSSxJQUFJQSxJQUFJO0FBQzlCO0FBRUEsU0FBU3FCLGFBQWNyQixDQUFDLEVBQUVvQixNQUFNLEVBQUU3QixNQUFNO0lBQ3RDLE9BQU9BLFNBQVNTLEtBQUssSUFBSUEsSUFBSW9CO0FBQy9CO0FBRUFvQixPQUFPQyxPQUFPLEdBQUd0RCIsInNvdXJjZXMiOlsid2VicGFjazovL25leHQtYWRtaW4tZGFzaGJvYXJkLy4vbm9kZV9tb2R1bGVzL3Bpbm8vbGliL211bHRpc3RyZWFtLmpzPzFkNTMiXSwic291cmNlc0NvbnRlbnQiOlsiJ3VzZSBzdHJpY3QnXG5cbmNvbnN0IG1ldGFkYXRhID0gU3ltYm9sLmZvcigncGluby5tZXRhZGF0YScpXG5jb25zdCB7IERFRkFVTFRfTEVWRUxTIH0gPSByZXF1aXJlKCcuL2NvbnN0YW50cycpXG5cbmNvbnN0IERFRkFVTFRfSU5GT19MRVZFTCA9IERFRkFVTFRfTEVWRUxTLmluZm9cblxuZnVuY3Rpb24gbXVsdGlzdHJlYW0gKHN0cmVhbXNBcnJheSwgb3B0cykge1xuICBsZXQgY291bnRlciA9IDBcbiAgc3RyZWFtc0FycmF5ID0gc3RyZWFtc0FycmF5IHx8IFtdXG4gIG9wdHMgPSBvcHRzIHx8IHsgZGVkdXBlOiBmYWxzZSB9XG5cbiAgY29uc3Qgc3RyZWFtTGV2ZWxzID0gT2JqZWN0LmNyZWF0ZShERUZBVUxUX0xFVkVMUylcbiAgc3RyZWFtTGV2ZWxzLnNpbGVudCA9IEluZmluaXR5XG4gIGlmIChvcHRzLmxldmVscyAmJiB0eXBlb2Ygb3B0cy5sZXZlbHMgPT09ICdvYmplY3QnKSB7XG4gICAgT2JqZWN0LmtleXMob3B0cy5sZXZlbHMpLmZvckVhY2goaSA9PiB7XG4gICAgICBzdHJlYW1MZXZlbHNbaV0gPSBvcHRzLmxldmVsc1tpXVxuICAgIH0pXG4gIH1cblxuICBjb25zdCByZXMgPSB7XG4gICAgd3JpdGUsXG4gICAgYWRkLFxuICAgIGVtaXQsXG4gICAgZmx1c2hTeW5jLFxuICAgIGVuZCxcbiAgICBtaW5MZXZlbDogMCxcbiAgICBzdHJlYW1zOiBbXSxcbiAgICBjbG9uZSxcbiAgICBbbWV0YWRhdGFdOiB0cnVlLFxuICAgIHN0cmVhbUxldmVsc1xuICB9XG5cbiAgaWYgKEFycmF5LmlzQXJyYXkoc3RyZWFtc0FycmF5KSkge1xuICAgIHN0cmVhbXNBcnJheS5mb3JFYWNoKGFkZCwgcmVzKVxuICB9IGVsc2Uge1xuICAgIGFkZC5jYWxsKHJlcywgc3RyZWFtc0FycmF5KVxuICB9XG5cbiAgLy8gY2xlYW4gdGhpcyBvYmplY3QgdXBcbiAgLy8gb3IgaXQgd2lsbCBzdGF5IGFsbG9jYXRlZCBmb3JldmVyXG4gIC8vIGFzIGl0IGlzIGNsb3NlZCBvbiB0aGUgZm9sbG93aW5nIGNsb3N1cmVzXG4gIHN0cmVhbXNBcnJheSA9IG51bGxcblxuICByZXR1cm4gcmVzXG5cbiAgLy8gd2UgY2FuIGV4aXQgZWFybHkgYmVjYXVzZSB0aGUgc3RyZWFtcyBhcmUgb3JkZXJlZCBieSBsZXZlbFxuICBmdW5jdGlvbiB3cml0ZSAoZGF0YSkge1xuICAgIGxldCBkZXN0XG4gICAgY29uc3QgbGV2ZWwgPSB0aGlzLmxhc3RMZXZlbFxuICAgIGNvbnN0IHsgc3RyZWFtcyB9ID0gdGhpc1xuICAgIC8vIGZvciBoYW5kbGluZyBzaXR1YXRpb24gd2hlbiBzZXZlcmFsIHN0cmVhbXMgaGFzIHRoZSBzYW1lIGxldmVsXG4gICAgbGV0IHJlY29yZGVkTGV2ZWwgPSAwXG4gICAgbGV0IHN0cmVhbVxuXG4gICAgLy8gaWYgZGVkdXBlIHNldCB0byB0cnVlIHdlIHNlbmQgbG9ncyB0byB0aGUgc3RyZWFtIHdpdGggdGhlIGhpZ2hlc3QgbGV2ZWxcbiAgICAvLyB0aGVyZWZvcmUsIHdlIGhhdmUgdG8gY2hhbmdlIHNvcnRpbmcgb3JkZXJcbiAgICBmb3IgKGxldCBpID0gaW5pdExvb3BWYXIoc3RyZWFtcy5sZW5ndGgsIG9wdHMuZGVkdXBlKTsgY2hlY2tMb29wVmFyKGksIHN0cmVhbXMubGVuZ3RoLCBvcHRzLmRlZHVwZSk7IGkgPSBhZGp1c3RMb29wVmFyKGksIG9wdHMuZGVkdXBlKSkge1xuICAgICAgZGVzdCA9IHN0cmVhbXNbaV1cbiAgICAgIGlmIChkZXN0LmxldmVsIDw9IGxldmVsKSB7XG4gICAgICAgIGlmIChyZWNvcmRlZExldmVsICE9PSAwICYmIHJlY29yZGVkTGV2ZWwgIT09IGRlc3QubGV2ZWwpIHtcbiAgICAgICAgICBicmVha1xuICAgICAgICB9XG4gICAgICAgIHN0cmVhbSA9IGRlc3Quc3RyZWFtXG4gICAgICAgIGlmIChzdHJlYW1bbWV0YWRhdGFdKSB7XG4gICAgICAgICAgY29uc3QgeyBsYXN0VGltZSwgbGFzdE1zZywgbGFzdE9iaiwgbGFzdExvZ2dlciB9ID0gdGhpc1xuICAgICAgICAgIHN0cmVhbS5sYXN0TGV2ZWwgPSBsZXZlbFxuICAgICAgICAgIHN0cmVhbS5sYXN0VGltZSA9IGxhc3RUaW1lXG4gICAgICAgICAgc3RyZWFtLmxhc3RNc2cgPSBsYXN0TXNnXG4gICAgICAgICAgc3RyZWFtLmxhc3RPYmogPSBsYXN0T2JqXG4gICAgICAgICAgc3RyZWFtLmxhc3RMb2dnZXIgPSBsYXN0TG9nZ2VyXG4gICAgICAgIH1cbiAgICAgICAgc3RyZWFtLndyaXRlKGRhdGEpXG4gICAgICAgIGlmIChvcHRzLmRlZHVwZSkge1xuICAgICAgICAgIHJlY29yZGVkTGV2ZWwgPSBkZXN0LmxldmVsXG4gICAgICAgIH1cbiAgICAgIH0gZWxzZSBpZiAoIW9wdHMuZGVkdXBlKSB7XG4gICAgICAgIGJyZWFrXG4gICAgICB9XG4gICAgfVxuICB9XG5cbiAgZnVuY3Rpb24gZW1pdCAoLi4uYXJncykge1xuICAgIGZvciAoY29uc3QgeyBzdHJlYW0gfSBvZiB0aGlzLnN0cmVhbXMpIHtcbiAgICAgIGlmICh0eXBlb2Ygc3RyZWFtLmVtaXQgPT09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgc3RyZWFtLmVtaXQoLi4uYXJncylcbiAgICAgIH1cbiAgICB9XG4gIH1cblxuICBmdW5jdGlvbiBmbHVzaFN5bmMgKCkge1xuICAgIGZvciAoY29uc3QgeyBzdHJlYW0gfSBvZiB0aGlzLnN0cmVhbXMpIHtcbiAgICAgIGlmICh0eXBlb2Ygc3RyZWFtLmZsdXNoU3luYyA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICBzdHJlYW0uZmx1c2hTeW5jKClcbiAgICAgIH1cbiAgICB9XG4gIH1cblxuICBmdW5jdGlvbiBhZGQgKGRlc3QpIHtcbiAgICBpZiAoIWRlc3QpIHtcbiAgICAgIHJldHVybiByZXNcbiAgICB9XG5cbiAgICAvLyBDaGVjayB0aGF0IGRlc3QgaW1wbGVtZW50cyBlaXRoZXIgU3RyZWFtRW50cnkgb3IgRGVzdGluYXRpb25TdHJlYW1cbiAgICBjb25zdCBpc1N0cmVhbSA9IHR5cGVvZiBkZXN0LndyaXRlID09PSAnZnVuY3Rpb24nIHx8IGRlc3Quc3RyZWFtXG4gICAgY29uc3Qgc3RyZWFtXyA9IGRlc3Qud3JpdGUgPyBkZXN0IDogZGVzdC5zdHJlYW1cbiAgICAvLyBUaGlzIGlzIG5lY2Vzc2FyeSB0byBwcm92aWRlIGEgbWVhbmluZ2Z1bCBlcnJvciBtZXNzYWdlLCBvdGhlcndpc2UgaXQgdGhyb3dzIHNvbWV3aGVyZSBpbnNpZGUgd3JpdGUoKVxuICAgIGlmICghaXNTdHJlYW0pIHtcbiAgICAgIHRocm93IEVycm9yKCdzdHJlYW0gb2JqZWN0IG5lZWRzIHRvIGltcGxlbWVudCBlaXRoZXIgU3RyZWFtRW50cnkgb3IgRGVzdGluYXRpb25TdHJlYW0gaW50ZXJmYWNlJylcbiAgICB9XG5cbiAgICBjb25zdCB7IHN0cmVhbXMsIHN0cmVhbUxldmVscyB9ID0gdGhpc1xuXG4gICAgbGV0IGxldmVsXG4gICAgaWYgKHR5cGVvZiBkZXN0LmxldmVsVmFsID09PSAnbnVtYmVyJykge1xuICAgICAgbGV2ZWwgPSBkZXN0LmxldmVsVmFsXG4gICAgfSBlbHNlIGlmICh0eXBlb2YgZGVzdC5sZXZlbCA9PT0gJ3N0cmluZycpIHtcbiAgICAgIGxldmVsID0gc3RyZWFtTGV2ZWxzW2Rlc3QubGV2ZWxdXG4gICAgfSBlbHNlIGlmICh0eXBlb2YgZGVzdC5sZXZlbCA9PT0gJ251bWJlcicpIHtcbiAgICAgIGxldmVsID0gZGVzdC5sZXZlbFxuICAgIH0gZWxzZSB7XG4gICAgICBsZXZlbCA9IERFRkFVTFRfSU5GT19MRVZFTFxuICAgIH1cblxuICAgIGNvbnN0IGRlc3RfID0ge1xuICAgICAgc3RyZWFtOiBzdHJlYW1fLFxuICAgICAgbGV2ZWwsXG4gICAgICBsZXZlbFZhbDogdW5kZWZpbmVkLFxuICAgICAgaWQ6IGNvdW50ZXIrK1xuICAgIH1cblxuICAgIHN0cmVhbXMudW5zaGlmdChkZXN0XylcbiAgICBzdHJlYW1zLnNvcnQoY29tcGFyZUJ5TGV2ZWwpXG5cbiAgICB0aGlzLm1pbkxldmVsID0gc3RyZWFtc1swXS5sZXZlbFxuXG4gICAgcmV0dXJuIHJlc1xuICB9XG5cbiAgZnVuY3Rpb24gZW5kICgpIHtcbiAgICBmb3IgKGNvbnN0IHsgc3RyZWFtIH0gb2YgdGhpcy5zdHJlYW1zKSB7XG4gICAgICBpZiAodHlwZW9mIHN0cmVhbS5mbHVzaFN5bmMgPT09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgc3RyZWFtLmZsdXNoU3luYygpXG4gICAgICB9XG4gICAgICBzdHJlYW0uZW5kKClcbiAgICB9XG4gIH1cblxuICBmdW5jdGlvbiBjbG9uZSAobGV2ZWwpIHtcbiAgICBjb25zdCBzdHJlYW1zID0gbmV3IEFycmF5KHRoaXMuc3RyZWFtcy5sZW5ndGgpXG5cbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IHN0cmVhbXMubGVuZ3RoOyBpKyspIHtcbiAgICAgIHN0cmVhbXNbaV0gPSB7XG4gICAgICAgIGxldmVsLFxuICAgICAgICBzdHJlYW06IHRoaXMuc3RyZWFtc1tpXS5zdHJlYW1cbiAgICAgIH1cbiAgICB9XG5cbiAgICByZXR1cm4ge1xuICAgICAgd3JpdGUsXG4gICAgICBhZGQsXG4gICAgICBtaW5MZXZlbDogbGV2ZWwsXG4gICAgICBzdHJlYW1zLFxuICAgICAgY2xvbmUsXG4gICAgICBlbWl0LFxuICAgICAgZmx1c2hTeW5jLFxuICAgICAgW21ldGFkYXRhXTogdHJ1ZVxuICAgIH1cbiAgfVxufVxuXG5mdW5jdGlvbiBjb21wYXJlQnlMZXZlbCAoYSwgYikge1xuICByZXR1cm4gYS5sZXZlbCAtIGIubGV2ZWxcbn1cblxuZnVuY3Rpb24gaW5pdExvb3BWYXIgKGxlbmd0aCwgZGVkdXBlKSB7XG4gIHJldHVybiBkZWR1cGUgPyBsZW5ndGggLSAxIDogMFxufVxuXG5mdW5jdGlvbiBhZGp1c3RMb29wVmFyIChpLCBkZWR1cGUpIHtcbiAgcmV0dXJuIGRlZHVwZSA/IGkgLSAxIDogaSArIDFcbn1cblxuZnVuY3Rpb24gY2hlY2tMb29wVmFyIChpLCBsZW5ndGgsIGRlZHVwZSkge1xuICByZXR1cm4gZGVkdXBlID8gaSA+PSAwIDogaSA8IGxlbmd0aFxufVxuXG5tb2R1bGUuZXhwb3J0cyA9IG11bHRpc3RyZWFtXG4iXSwibmFtZXMiOlsibWV0YWRhdGEiLCJTeW1ib2wiLCJmb3IiLCJERUZBVUxUX0xFVkVMUyIsInJlcXVpcmUiLCJERUZBVUxUX0lORk9fTEVWRUwiLCJpbmZvIiwibXVsdGlzdHJlYW0iLCJzdHJlYW1zQXJyYXkiLCJvcHRzIiwiY291bnRlciIsImRlZHVwZSIsInN0cmVhbUxldmVscyIsIk9iamVjdCIsImNyZWF0ZSIsInNpbGVudCIsIkluZmluaXR5IiwibGV2ZWxzIiwia2V5cyIsImZvckVhY2giLCJpIiwicmVzIiwid3JpdGUiLCJhZGQiLCJlbWl0IiwiZmx1c2hTeW5jIiwiZW5kIiwibWluTGV2ZWwiLCJzdHJlYW1zIiwiY2xvbmUiLCJBcnJheSIsImlzQXJyYXkiLCJjYWxsIiwiZGF0YSIsImRlc3QiLCJsZXZlbCIsImxhc3RMZXZlbCIsInJlY29yZGVkTGV2ZWwiLCJzdHJlYW0iLCJpbml0TG9vcFZhciIsImxlbmd0aCIsImNoZWNrTG9vcFZhciIsImFkanVzdExvb3BWYXIiLCJsYXN0VGltZSIsImxhc3RNc2ciLCJsYXN0T2JqIiwibGFzdExvZ2dlciIsImFyZ3MiLCJpc1N0cmVhbSIsInN0cmVhbV8iLCJFcnJvciIsImxldmVsVmFsIiwiZGVzdF8iLCJ1bmRlZmluZWQiLCJpZCIsInVuc2hpZnQiLCJzb3J0IiwiY29tcGFyZUJ5TGV2ZWwiLCJhIiwiYiIsIm1vZHVsZSIsImV4cG9ydHMiXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/pino/lib/multistream.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/pino/lib/proto.js":
/*!****************************************!*\
  !*** ./node_modules/pino/lib/proto.js ***!
  \****************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

eval("\n/* eslint no-prototype-builtins: 0 */ const { EventEmitter } = __webpack_require__(/*! node:events */ \"node:events\");\nconst { lsCacheSym, levelValSym, setLevelSym, getLevelSym, chindingsSym, parsedChindingsSym, mixinSym, asJsonSym, writeSym, mixinMergeStrategySym, timeSym, timeSliceIndexSym, streamSym, serializersSym, formattersSym, errorKeySym, messageKeySym, useOnlyCustomLevelsSym, needsMetadataGsym, redactFmtSym, stringifySym, formatOptsSym, stringifiersSym, msgPrefixSym, hooksSym } = __webpack_require__(/*! ./symbols */ \"(ssr)/./node_modules/pino/lib/symbols.js\");\nconst { getLevel, setLevel, isLevelEnabled, mappings, initialLsCache, genLsCache, assertNoLevelCollisions } = __webpack_require__(/*! ./levels */ \"(ssr)/./node_modules/pino/lib/levels.js\");\nconst { asChindings, asJson, buildFormatters, stringify } = __webpack_require__(/*! ./tools */ \"(ssr)/./node_modules/pino/lib/tools.js\");\nconst { version } = __webpack_require__(/*! ./meta */ \"(ssr)/./node_modules/pino/lib/meta.js\");\nconst redaction = __webpack_require__(/*! ./redaction */ \"(ssr)/./node_modules/pino/lib/redaction.js\");\n// note: use of class is satirical\n// https://github.com/pinojs/pino/pull/433#pullrequestreview-127703127\nconst constructor = class Pino {\n};\nconst prototype = {\n    constructor,\n    child,\n    bindings,\n    setBindings,\n    flush,\n    isLevelEnabled,\n    version,\n    get level () {\n        return this[getLevelSym]();\n    },\n    set level (lvl){\n        this[setLevelSym](lvl);\n    },\n    get levelVal () {\n        return this[levelValSym];\n    },\n    set levelVal (n){\n        throw Error(\"levelVal is read-only\");\n    },\n    [lsCacheSym]: initialLsCache,\n    [writeSym]: write,\n    [asJsonSym]: asJson,\n    [getLevelSym]: getLevel,\n    [setLevelSym]: setLevel\n};\nObject.setPrototypeOf(prototype, EventEmitter.prototype);\n// exporting and consuming the prototype object using factory pattern fixes scoping issues with getters when serializing\nmodule.exports = function() {\n    return Object.create(prototype);\n};\nconst resetChildingsFormatter = (bindings)=>bindings;\nfunction child(bindings, options) {\n    if (!bindings) {\n        throw Error(\"missing bindings for child Pino\");\n    }\n    options = options || {} // default options to empty object\n    ;\n    const serializers = this[serializersSym];\n    const formatters = this[formattersSym];\n    const instance = Object.create(this);\n    if (options.hasOwnProperty(\"serializers\") === true) {\n        instance[serializersSym] = Object.create(null);\n        for(const k in serializers){\n            instance[serializersSym][k] = serializers[k];\n        }\n        const parentSymbols = Object.getOwnPropertySymbols(serializers);\n        /* eslint no-var: off */ for(var i = 0; i < parentSymbols.length; i++){\n            const ks = parentSymbols[i];\n            instance[serializersSym][ks] = serializers[ks];\n        }\n        for(const bk in options.serializers){\n            instance[serializersSym][bk] = options.serializers[bk];\n        }\n        const bindingsSymbols = Object.getOwnPropertySymbols(options.serializers);\n        for(var bi = 0; bi < bindingsSymbols.length; bi++){\n            const bks = bindingsSymbols[bi];\n            instance[serializersSym][bks] = options.serializers[bks];\n        }\n    } else instance[serializersSym] = serializers;\n    if (options.hasOwnProperty(\"formatters\")) {\n        const { level, bindings: chindings, log } = options.formatters;\n        instance[formattersSym] = buildFormatters(level || formatters.level, chindings || resetChildingsFormatter, log || formatters.log);\n    } else {\n        instance[formattersSym] = buildFormatters(formatters.level, resetChildingsFormatter, formatters.log);\n    }\n    if (options.hasOwnProperty(\"customLevels\") === true) {\n        assertNoLevelCollisions(this.levels, options.customLevels);\n        instance.levels = mappings(options.customLevels, instance[useOnlyCustomLevelsSym]);\n        genLsCache(instance);\n    }\n    // redact must place before asChindings and only replace if exist\n    if (typeof options.redact === \"object\" && options.redact !== null || Array.isArray(options.redact)) {\n        instance.redact = options.redact // replace redact directly\n        ;\n        const stringifiers = redaction(instance.redact, stringify);\n        const formatOpts = {\n            stringify: stringifiers[redactFmtSym]\n        };\n        instance[stringifySym] = stringify;\n        instance[stringifiersSym] = stringifiers;\n        instance[formatOptsSym] = formatOpts;\n    }\n    if (typeof options.msgPrefix === \"string\") {\n        instance[msgPrefixSym] = (this[msgPrefixSym] || \"\") + options.msgPrefix;\n    }\n    instance[chindingsSym] = asChindings(instance, bindings);\n    const childLevel = options.level || this.level;\n    instance[setLevelSym](childLevel);\n    this.onChild(instance);\n    return instance;\n}\nfunction bindings() {\n    const chindings = this[chindingsSym];\n    const chindingsJson = `{${chindings.substr(1)}}` // at least contains ,\"pid\":7068,\"hostname\":\"myMac\"\n    ;\n    const bindingsFromJson = JSON.parse(chindingsJson);\n    delete bindingsFromJson.pid;\n    delete bindingsFromJson.hostname;\n    return bindingsFromJson;\n}\nfunction setBindings(newBindings) {\n    const chindings = asChindings(this, newBindings);\n    this[chindingsSym] = chindings;\n    delete this[parsedChindingsSym];\n}\n/**\n * Default strategy for creating `mergeObject` from arguments and the result from `mixin()`.\n * Fields from `mergeObject` have higher priority in this strategy.\n *\n * @param {Object} mergeObject The object a user has supplied to the logging function.\n * @param {Object} mixinObject The result of the `mixin` method.\n * @return {Object}\n */ function defaultMixinMergeStrategy(mergeObject, mixinObject) {\n    return Object.assign(mixinObject, mergeObject);\n}\nfunction write(_obj, msg, num) {\n    const t = this[timeSym]();\n    const mixin = this[mixinSym];\n    const errorKey = this[errorKeySym];\n    const messageKey = this[messageKeySym];\n    const mixinMergeStrategy = this[mixinMergeStrategySym] || defaultMixinMergeStrategy;\n    let obj;\n    const streamWriteHook = this[hooksSym].streamWrite;\n    if (_obj === undefined || _obj === null) {\n        obj = {};\n    } else if (_obj instanceof Error) {\n        obj = {\n            [errorKey]: _obj\n        };\n        if (msg === undefined) {\n            msg = _obj.message;\n        }\n    } else {\n        obj = _obj;\n        if (msg === undefined && _obj[messageKey] === undefined && _obj[errorKey]) {\n            msg = _obj[errorKey].message;\n        }\n    }\n    if (mixin) {\n        obj = mixinMergeStrategy(obj, mixin(obj, num, this));\n    }\n    const s = this[asJsonSym](obj, msg, num, t);\n    const stream = this[streamSym];\n    if (stream[needsMetadataGsym] === true) {\n        stream.lastLevel = num;\n        stream.lastObj = obj;\n        stream.lastMsg = msg;\n        stream.lastTime = t.slice(this[timeSliceIndexSym]);\n        stream.lastLogger = this // for child loggers\n        ;\n    }\n    stream.write(streamWriteHook ? streamWriteHook(s) : s);\n}\nfunction noop() {}\nfunction flush(cb) {\n    if (cb != null && typeof cb !== \"function\") {\n        throw Error(\"callback must be a function\");\n    }\n    const stream = this[streamSym];\n    if (typeof stream.flush === \"function\") {\n        stream.flush(cb || noop);\n    } else if (cb) cb();\n}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,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LE1BQU1ELG1CQUFtQkMsS0FBS0osTUFBTUksS0FBS04sS0FBSyxJQUFJO0lBQ3BEO0lBRUEsTUFBTVcsSUFBSSxJQUFJLENBQUN0RyxVQUFVLENBQUNpRyxLQUFLUCxLQUFLQyxLQUFLQztJQUV6QyxNQUFNVyxTQUFTLElBQUksQ0FBQ2xHLFVBQVU7SUFDOUIsSUFBSWtHLE1BQU0sQ0FBQzVGLGtCQUFrQixLQUFLLE1BQU07UUFDdEM0RixPQUFPQyxTQUFTLEdBQUdiO1FBQ25CWSxPQUFPRSxPQUFPLEdBQUdSO1FBQ2pCTSxPQUFPRyxPQUFPLEdBQUdoQjtRQUNqQmEsT0FBT0ksUUFBUSxHQUFHZixFQUFFZ0IsS0FBSyxDQUFDLElBQUksQ0FBQ3hHLGtCQUFrQjtRQUNqRG1HLE9BQU9NLFVBQVUsR0FBRyxJQUFJLENBQUMsb0JBQW9COztJQUMvQztJQUNBTixPQUFPNUQsS0FBSyxDQUFDdUQsa0JBQWtCQSxnQkFBZ0JJLEtBQUtBO0FBQ3REO0FBRUEsU0FBU1EsUUFBUztBQUVsQixTQUFTekUsTUFBTzBFLEVBQUU7SUFDaEIsSUFBSUEsTUFBTSxRQUFRLE9BQU9BLE9BQU8sWUFBWTtRQUMxQyxNQUFNckUsTUFBTTtJQUNkO0lBRUEsTUFBTTZELFNBQVMsSUFBSSxDQUFDbEcsVUFBVTtJQUU5QixJQUFJLE9BQU9rRyxPQUFPbEUsS0FBSyxLQUFLLFlBQVk7UUFDdENrRSxPQUFPbEUsS0FBSyxDQUFDMEUsTUFBTUQ7SUFDckIsT0FBTyxJQUFJQyxJQUFJQTtBQUNqQiIsInNvdXJjZXMiOlsid2VicGFjazovL25leHQtYWRtaW4tZGFzaGJvYXJkLy4vbm9kZV9tb2R1bGVzL3Bpbm8vbGliL3Byb3RvLmpzP2UwZGUiXSwic291cmNlc0NvbnRlbnQiOlsiJ3VzZSBzdHJpY3QnXG5cbi8qIGVzbGludCBuby1wcm90b3R5cGUtYnVpbHRpbnM6IDAgKi9cblxuY29uc3QgeyBFdmVudEVtaXR0ZXIgfSA9IHJlcXVpcmUoJ25vZGU6ZXZlbnRzJylcbmNvbnN0IHtcbiAgbHNDYWNoZVN5bSxcbiAgbGV2ZWxWYWxTeW0sXG4gIHNldExldmVsU3ltLFxuICBnZXRMZXZlbFN5bSxcbiAgY2hpbmRpbmdzU3ltLFxuICBwYXJzZWRDaGluZGluZ3NTeW0sXG4gIG1peGluU3ltLFxuICBhc0pzb25TeW0sXG4gIHdyaXRlU3ltLFxuICBtaXhpbk1lcmdlU3RyYXRlZ3lTeW0sXG4gIHRpbWVTeW0sXG4gIHRpbWVTbGljZUluZGV4U3ltLFxuICBzdHJlYW1TeW0sXG4gIHNlcmlhbGl6ZXJzU3ltLFxuICBmb3JtYXR0ZXJzU3ltLFxuICBlcnJvcktleVN5bSxcbiAgbWVzc2FnZUtleVN5bSxcbiAgdXNlT25seUN1c3RvbUxldmVsc1N5bSxcbiAgbmVlZHNNZXRhZGF0YUdzeW0sXG4gIHJlZGFjdEZtdFN5bSxcbiAgc3RyaW5naWZ5U3ltLFxuICBmb3JtYXRPcHRzU3ltLFxuICBzdHJpbmdpZmllcnNTeW0sXG4gIG1zZ1ByZWZpeFN5bSxcbiAgaG9va3NTeW1cbn0gPSByZXF1aXJlKCcuL3N5bWJvbHMnKVxuY29uc3Qge1xuICBnZXRMZXZlbCxcbiAgc2V0TGV2ZWwsXG4gIGlzTGV2ZWxFbmFibGVkLFxuICBtYXBwaW5ncyxcbiAgaW5pdGlhbExzQ2FjaGUsXG4gIGdlbkxzQ2FjaGUsXG4gIGFzc2VydE5vTGV2ZWxDb2xsaXNpb25zXG59ID0gcmVxdWlyZSgnLi9sZXZlbHMnKVxuY29uc3Qge1xuICBhc0NoaW5kaW5ncyxcbiAgYXNKc29uLFxuICBidWlsZEZvcm1hdHRlcnMsXG4gIHN0cmluZ2lmeVxufSA9IHJlcXVpcmUoJy4vdG9vbHMnKVxuY29uc3Qge1xuICB2ZXJzaW9uXG59ID0gcmVxdWlyZSgnLi9tZXRhJylcbmNvbnN0IHJlZGFjdGlvbiA9IHJlcXVpcmUoJy4vcmVkYWN0aW9uJylcblxuLy8gbm90ZTogdXNlIG9mIGNsYXNzIGlzIHNhdGlyaWNhbFxuLy8gaHR0cHM6Ly9naXRodWIuY29tL3Bpbm9qcy9waW5vL3B1bGwvNDMzI3B1bGxyZXF1ZXN0cmV2aWV3LTEyNzcwMzEyN1xuY29uc3QgY29uc3RydWN0b3IgPSBjbGFzcyBQaW5vIHt9XG5jb25zdCBwcm90b3R5cGUgPSB7XG4gIGNvbnN0cnVjdG9yLFxuICBjaGlsZCxcbiAgYmluZGluZ3MsXG4gIHNldEJpbmRpbmdzLFxuICBmbHVzaCxcbiAgaXNMZXZlbEVuYWJsZWQsXG4gIHZlcnNpb24sXG4gIGdldCBsZXZlbCAoKSB7IHJldHVybiB0aGlzW2dldExldmVsU3ltXSgpIH0sXG4gIHNldCBsZXZlbCAobHZsKSB7IHRoaXNbc2V0TGV2ZWxTeW1dKGx2bCkgfSxcbiAgZ2V0IGxldmVsVmFsICgpIHsgcmV0dXJuIHRoaXNbbGV2ZWxWYWxTeW1dIH0sXG4gIHNldCBsZXZlbFZhbCAobikgeyB0aHJvdyBFcnJvcignbGV2ZWxWYWwgaXMgcmVhZC1vbmx5JykgfSxcbiAgW2xzQ2FjaGVTeW1dOiBpbml0aWFsTHNDYWNoZSxcbiAgW3dyaXRlU3ltXTogd3JpdGUsXG4gIFthc0pzb25TeW1dOiBhc0pzb24sXG4gIFtnZXRMZXZlbFN5bV06IGdldExldmVsLFxuICBbc2V0TGV2ZWxTeW1dOiBzZXRMZXZlbFxufVxuXG5PYmplY3Quc2V0UHJvdG90eXBlT2YocHJvdG90eXBlLCBFdmVudEVtaXR0ZXIucHJvdG90eXBlKVxuXG4vLyBleHBvcnRpbmcgYW5kIGNvbnN1bWluZyB0aGUgcHJvdG90eXBlIG9iamVjdCB1c2luZyBmYWN0b3J5IHBhdHRlcm4gZml4ZXMgc2NvcGluZyBpc3N1ZXMgd2l0aCBnZXR0ZXJzIHdoZW4gc2VyaWFsaXppbmdcbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gKCkge1xuICByZXR1cm4gT2JqZWN0LmNyZWF0ZShwcm90b3R5cGUpXG59XG5cbmNvbnN0IHJlc2V0Q2hpbGRpbmdzRm9ybWF0dGVyID0gYmluZGluZ3MgPT4gYmluZGluZ3NcbmZ1bmN0aW9uIGNoaWxkIChiaW5kaW5ncywgb3B0aW9ucykge1xuICBpZiAoIWJpbmRpbmdzKSB7XG4gICAgdGhyb3cgRXJyb3IoJ21pc3NpbmcgYmluZGluZ3MgZm9yIGNoaWxkIFBpbm8nKVxuICB9XG4gIG9wdGlvbnMgPSBvcHRpb25zIHx8IHt9IC8vIGRlZmF1bHQgb3B0aW9ucyB0byBlbXB0eSBvYmplY3RcbiAgY29uc3Qgc2VyaWFsaXplcnMgPSB0aGlzW3NlcmlhbGl6ZXJzU3ltXVxuICBjb25zdCBmb3JtYXR0ZXJzID0gdGhpc1tmb3JtYXR0ZXJzU3ltXVxuICBjb25zdCBpbnN0YW5jZSA9IE9iamVjdC5jcmVhdGUodGhpcylcblxuICBpZiAob3B0aW9ucy5oYXNPd25Qcm9wZXJ0eSgnc2VyaWFsaXplcnMnKSA9PT0gdHJ1ZSkge1xuICAgIGluc3RhbmNlW3NlcmlhbGl6ZXJzU3ltXSA9IE9iamVjdC5jcmVhdGUobnVsbClcblxuICAgIGZvciAoY29uc3QgayBpbiBzZXJpYWxpemVycykge1xuICAgICAgaW5zdGFuY2Vbc2VyaWFsaXplcnNTeW1dW2tdID0gc2VyaWFsaXplcnNba11cbiAgICB9XG4gICAgY29uc3QgcGFyZW50U3ltYm9scyA9IE9iamVjdC5nZXRPd25Qcm9wZXJ0eVN5bWJvbHMoc2VyaWFsaXplcnMpXG4gICAgLyogZXNsaW50IG5vLXZhcjogb2ZmICovXG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBwYXJlbnRTeW1ib2xzLmxlbmd0aDsgaSsrKSB7XG4gICAgICBjb25zdCBrcyA9IHBhcmVudFN5bWJvbHNbaV1cbiAgICAgIGluc3RhbmNlW3NlcmlhbGl6ZXJzU3ltXVtrc10gPSBzZXJpYWxpemVyc1trc11cbiAgICB9XG5cbiAgICBmb3IgKGNvbnN0IGJrIGluIG9wdGlvbnMuc2VyaWFsaXplcnMpIHtcbiAgICAgIGluc3RhbmNlW3NlcmlhbGl6ZXJzU3ltXVtia10gPSBvcHRpb25zLnNlcmlhbGl6ZXJzW2JrXVxuICAgIH1cbiAgICBjb25zdCBiaW5kaW5nc1N5bWJvbHMgPSBPYmplY3QuZ2V0T3duUHJvcGVydHlTeW1ib2xzKG9wdGlvbnMuc2VyaWFsaXplcnMpXG4gICAgZm9yICh2YXIgYmkgPSAwOyBiaSA8IGJpbmRpbmdzU3ltYm9scy5sZW5ndGg7IGJpKyspIHtcbiAgICAgIGNvbnN0IGJrcyA9IGJpbmRpbmdzU3ltYm9sc1tiaV1cbiAgICAgIGluc3RhbmNlW3NlcmlhbGl6ZXJzU3ltXVtia3NdID0gb3B0aW9ucy5zZXJpYWxpemVyc1tia3NdXG4gICAgfVxuICB9IGVsc2UgaW5zdGFuY2Vbc2VyaWFsaXplcnNTeW1dID0gc2VyaWFsaXplcnNcbiAgaWYgKG9wdGlvbnMuaGFzT3duUHJvcGVydHkoJ2Zvcm1hdHRlcnMnKSkge1xuICAgIGNvbnN0IHsgbGV2ZWwsIGJpbmRpbmdzOiBjaGluZGluZ3MsIGxvZyB9ID0gb3B0aW9ucy5mb3JtYXR0ZXJzXG4gICAgaW5zdGFuY2VbZm9ybWF0dGVyc1N5bV0gPSBidWlsZEZvcm1hdHRlcnMoXG4gICAgICBsZXZlbCB8fCBmb3JtYXR0ZXJzLmxldmVsLFxuICAgICAgY2hpbmRpbmdzIHx8IHJlc2V0Q2hpbGRpbmdzRm9ybWF0dGVyLFxuICAgICAgbG9nIHx8IGZvcm1hdHRlcnMubG9nXG4gICAgKVxuICB9IGVsc2Uge1xuICAgIGluc3RhbmNlW2Zvcm1hdHRlcnNTeW1dID0gYnVpbGRGb3JtYXR0ZXJzKFxuICAgICAgZm9ybWF0dGVycy5sZXZlbCxcbiAgICAgIHJlc2V0Q2hpbGRpbmdzRm9ybWF0dGVyLFxuICAgICAgZm9ybWF0dGVycy5sb2dcbiAgICApXG4gIH1cbiAgaWYgKG9wdGlvbnMuaGFzT3duUHJvcGVydHkoJ2N1c3RvbUxldmVscycpID09PSB0cnVlKSB7XG4gICAgYXNzZXJ0Tm9MZXZlbENvbGxpc2lvbnModGhpcy5sZXZlbHMsIG9wdGlvbnMuY3VzdG9tTGV2ZWxzKVxuICAgIGluc3RhbmNlLmxldmVscyA9IG1hcHBpbmdzKG9wdGlvbnMuY3VzdG9tTGV2ZWxzLCBpbnN0YW5jZVt1c2VPbmx5Q3VzdG9tTGV2ZWxzU3ltXSlcbiAgICBnZW5Mc0NhY2hlKGluc3RhbmNlKVxuICB9XG5cbiAgLy8gcmVkYWN0IG11c3QgcGxhY2UgYmVmb3JlIGFzQ2hpbmRpbmdzIGFuZCBvbmx5IHJlcGxhY2UgaWYgZXhpc3RcbiAgaWYgKCh0eXBlb2Ygb3B0aW9ucy5yZWRhY3QgPT09ICdvYmplY3QnICYmIG9wdGlvbnMucmVkYWN0ICE9PSBudWxsKSB8fCBBcnJheS5pc0FycmF5KG9wdGlvbnMucmVkYWN0KSkge1xuICAgIGluc3RhbmNlLnJlZGFjdCA9IG9wdGlvbnMucmVkYWN0IC8vIHJlcGxhY2UgcmVkYWN0IGRpcmVjdGx5XG4gICAgY29uc3Qgc3RyaW5naWZpZXJzID0gcmVkYWN0aW9uKGluc3RhbmNlLnJlZGFjdCwgc3RyaW5naWZ5KVxuICAgIGNvbnN0IGZvcm1hdE9wdHMgPSB7IHN0cmluZ2lmeTogc3RyaW5naWZpZXJzW3JlZGFjdEZtdFN5bV0gfVxuICAgIGluc3RhbmNlW3N0cmluZ2lmeVN5bV0gPSBzdHJpbmdpZnlcbiAgICBpbnN0YW5jZVtzdHJpbmdpZmllcnNTeW1dID0gc3RyaW5naWZpZXJzXG4gICAgaW5zdGFuY2VbZm9ybWF0T3B0c1N5bV0gPSBmb3JtYXRPcHRzXG4gIH1cblxuICBpZiAodHlwZW9mIG9wdGlvbnMubXNnUHJlZml4ID09PSAnc3RyaW5nJykge1xuICAgIGluc3RhbmNlW21zZ1ByZWZpeFN5bV0gPSAodGhpc1ttc2dQcmVmaXhTeW1dIHx8ICcnKSArIG9wdGlvbnMubXNnUHJlZml4XG4gIH1cblxuICBpbnN0YW5jZVtjaGluZGluZ3NTeW1dID0gYXNDaGluZGluZ3MoaW5zdGFuY2UsIGJpbmRpbmdzKVxuICBjb25zdCBjaGlsZExldmVsID0gb3B0aW9ucy5sZXZlbCB8fCB0aGlzLmxldmVsXG4gIGluc3RhbmNlW3NldExldmVsU3ltXShjaGlsZExldmVsKVxuICB0aGlzLm9uQ2hpbGQoaW5zdGFuY2UpXG4gIHJldHVybiBpbnN0YW5jZVxufVxuXG5mdW5jdGlvbiBiaW5kaW5ncyAoKSB7XG4gIGNvbnN0IGNoaW5kaW5ncyA9IHRoaXNbY2hpbmRpbmdzU3ltXVxuICBjb25zdCBjaGluZGluZ3NKc29uID0gYHske2NoaW5kaW5ncy5zdWJzdHIoMSl9fWAgLy8gYXQgbGVhc3QgY29udGFpbnMgLFwicGlkXCI6NzA2OCxcImhvc3RuYW1lXCI6XCJteU1hY1wiXG4gIGNvbnN0IGJpbmRpbmdzRnJvbUpzb24gPSBKU09OLnBhcnNlKGNoaW5kaW5nc0pzb24pXG4gIGRlbGV0ZSBiaW5kaW5nc0Zyb21Kc29uLnBpZFxuICBkZWxldGUgYmluZGluZ3NGcm9tSnNvbi5ob3N0bmFtZVxuICByZXR1cm4gYmluZGluZ3NGcm9tSnNvblxufVxuXG5mdW5jdGlvbiBzZXRCaW5kaW5ncyAobmV3QmluZGluZ3MpIHtcbiAgY29uc3QgY2hpbmRpbmdzID0gYXNDaGluZGluZ3ModGhpcywgbmV3QmluZGluZ3MpXG4gIHRoaXNbY2hpbmRpbmdzU3ltXSA9IGNoaW5kaW5nc1xuICBkZWxldGUgdGhpc1twYXJzZWRDaGluZGluZ3NTeW1dXG59XG5cbi8qKlxuICogRGVmYXVsdCBzdHJhdGVneSBmb3IgY3JlYXRpbmcgYG1lcmdlT2JqZWN0YCBmcm9tIGFyZ3VtZW50cyBhbmQgdGhlIHJlc3VsdCBmcm9tIGBtaXhpbigpYC5cbiAqIEZpZWxkcyBmcm9tIGBtZXJnZU9iamVjdGAgaGF2ZSBoaWdoZXIgcHJpb3JpdHkgaW4gdGhpcyBzdHJhdGVneS5cbiAqXG4gKiBAcGFyYW0ge09iamVjdH0gbWVyZ2VPYmplY3QgVGhlIG9iamVjdCBhIHVzZXIgaGFzIHN1cHBsaWVkIHRvIHRoZSBsb2dnaW5nIGZ1bmN0aW9uLlxuICogQHBhcmFtIHtPYmplY3R9IG1peGluT2JqZWN0IFRoZSByZXN1bHQgb2YgdGhlIGBtaXhpbmAgbWV0aG9kLlxuICogQHJldHVybiB7T2JqZWN0fVxuICovXG5mdW5jdGlvbiBkZWZhdWx0TWl4aW5NZXJnZVN0cmF0ZWd5IChtZXJnZU9iamVjdCwgbWl4aW5PYmplY3QpIHtcbiAgcmV0dXJuIE9iamVjdC5hc3NpZ24obWl4aW5PYmplY3QsIG1lcmdlT2JqZWN0KVxufVxuXG5mdW5jdGlvbiB3cml0ZSAoX29iaiwgbXNnLCBudW0pIHtcbiAgY29uc3QgdCA9IHRoaXNbdGltZVN5bV0oKVxuICBjb25zdCBtaXhpbiA9IHRoaXNbbWl4aW5TeW1dXG4gIGNvbnN0IGVycm9yS2V5ID0gdGhpc1tlcnJvcktleVN5bV1cbiAgY29uc3QgbWVzc2FnZUtleSA9IHRoaXNbbWVzc2FnZUtleVN5bV1cbiAgY29uc3QgbWl4aW5NZXJnZVN0cmF0ZWd5ID0gdGhpc1ttaXhpbk1lcmdlU3RyYXRlZ3lTeW1dIHx8IGRlZmF1bHRNaXhpbk1lcmdlU3RyYXRlZ3lcbiAgbGV0IG9ialxuICBjb25zdCBzdHJlYW1Xcml0ZUhvb2sgPSB0aGlzW2hvb2tzU3ltXS5zdHJlYW1Xcml0ZVxuXG4gIGlmIChfb2JqID09PSB1bmRlZmluZWQgfHwgX29iaiA9PT0gbnVsbCkge1xuICAgIG9iaiA9IHt9XG4gIH0gZWxzZSBpZiAoX29iaiBpbnN0YW5jZW9mIEVycm9yKSB7XG4gICAgb2JqID0geyBbZXJyb3JLZXldOiBfb2JqIH1cbiAgICBpZiAobXNnID09PSB1bmRlZmluZWQpIHtcbiAgICAgIG1zZyA9IF9vYmoubWVzc2FnZVxuICAgIH1cbiAgfSBlbHNlIHtcbiAgICBvYmogPSBfb2JqXG4gICAgaWYgKG1zZyA9PT0gdW5kZWZpbmVkICYmIF9vYmpbbWVzc2FnZUtleV0gPT09IHVuZGVmaW5lZCAmJiBfb2JqW2Vycm9yS2V5XSkge1xuICAgICAgbXNnID0gX29ialtlcnJvcktleV0ubWVzc2FnZVxuICAgIH1cbiAgfVxuXG4gIGlmIChtaXhpbikge1xuICAgIG9iaiA9IG1peGluTWVyZ2VTdHJhdGVneShvYmosIG1peGluKG9iaiwgbnVtLCB0aGlzKSlcbiAgfVxuXG4gIGNvbnN0IHMgPSB0aGlzW2FzSnNvblN5bV0ob2JqLCBtc2csIG51bSwgdClcblxuICBjb25zdCBzdHJlYW0gPSB0aGlzW3N0cmVhbVN5bV1cbiAgaWYgKHN0cmVhbVtuZWVkc01ldGFkYXRhR3N5bV0gPT09IHRydWUpIHtcbiAgICBzdHJlYW0ubGFzdExldmVsID0gbnVtXG4gICAgc3RyZWFtLmxhc3RPYmogPSBvYmpcbiAgICBzdHJlYW0ubGFzdE1zZyA9IG1zZ1xuICAgIHN0cmVhbS5sYXN0VGltZSA9IHQuc2xpY2UodGhpc1t0aW1lU2xpY2VJbmRleFN5bV0pXG4gICAgc3RyZWFtLmxhc3RMb2dnZXIgPSB0aGlzIC8vIGZvciBjaGlsZCBsb2dnZXJzXG4gIH1cbiAgc3RyZWFtLndyaXRlKHN0cmVhbVdyaXRlSG9vayA/IHN0cmVhbVdyaXRlSG9vayhzKSA6IHMpXG59XG5cbmZ1bmN0aW9uIG5vb3AgKCkge31cblxuZnVuY3Rpb24gZmx1c2ggKGNiKSB7XG4gIGlmIChjYiAhPSBudWxsICYmIHR5cGVvZiBjYiAhPT0gJ2Z1bmN0aW9uJykge1xuICAgIHRocm93IEVycm9yKCdjYWxsYmFjayBtdXN0IGJlIGEgZnVuY3Rpb24nKVxuICB9XG5cbiAgY29uc3Qgc3RyZWFtID0gdGhpc1tzdHJlYW1TeW1dXG5cbiAgaWYgKHR5cGVvZiBzdHJlYW0uZmx1c2ggPT09ICdmdW5jdGlvbicpIHtcbiAgICBzdHJlYW0uZmx1c2goY2IgfHwgbm9vcClcbiAgfSBlbHNlIGlmIChjYikgY2IoKVxufVxuIl0sIm5hbWVzIjpbIkV2ZW50RW1pdHRlciIsInJlcXVpcmUiLCJsc0NhY2hlU3ltIiwibGV2ZWxWYWxTeW0iLCJzZXRMZXZlbFN5bSIsImdldExldmVsU3ltIiwiY2hpbmRpbmdzU3ltIiwicGFyc2VkQ2hpbmRpbmdzU3ltIiwibWl4aW5TeW0iLCJhc0pzb25TeW0iLCJ3cml0ZVN5bSIsIm1peGluTWVyZ2VTdHJhdGVneVN5bSIsInRpbWVTeW0iLCJ0aW1lU2xpY2VJbmRleFN5bSIsInN0cmVhbVN5bSIsInNlcmlhbGl6ZXJzU3ltIiwiZm9ybWF0dGVyc1N5bSIsImVycm9yS2V5U3ltIiwibWVzc2FnZUtleVN5bSIsInVzZU9ubHlDdXN0b21MZXZlbHNTeW0iLCJuZWVkc01ldGFkYXRhR3N5bSIsInJlZGFjdEZtdFN5bSIsInN0cmluZ2lmeVN5bSIsImZvcm1hdE9wdHNTeW0iLCJzdHJpbmdpZmllcnNTeW0iLCJtc2dQcmVmaXhTeW0iLCJob29rc1N5bSIsImdldExldmVsIiwic2V0TGV2ZWwiLCJpc0xldmVsRW5hYmxlZCIsIm1hcHBpbmdzIiwiaW5pdGlhbExzQ2FjaGUiLCJnZW5Mc0NhY2hlIiwiYXNzZXJ0Tm9MZXZlbENvbGxpc2lvbnMiLCJhc0NoaW5kaW5ncyIsImFzSnNvbiIsImJ1aWxkRm9ybWF0dGVycyIsInN0cmluZ2lmeSIsInZlcnNpb24iLCJyZWRhY3Rpb24iLCJjb25zdHJ1Y3RvciIsIlBpbm8iLCJwcm90b3R5cGUiLCJjaGlsZCIsImJpbmRpbmdzIiwic2V0QmluZGluZ3MiLCJmbHVzaCIsImxldmVsIiwibHZsIiwibGV2ZWxWYWwiLCJuIiwiRXJyb3IiLCJ3cml0ZSIsIk9iamVjdCIsInNldFByb3RvdHlwZU9mIiwibW9kdWxlIiwiZXhwb3J0cyIsImNyZWF0ZSIsInJlc2V0Q2hpbGRpbmdzRm9ybWF0dGVyIiwib3B0aW9ucyIsInNlcmlhbGl6ZXJzIiwiZm9ybWF0dGVycyIsImluc3RhbmNlIiwiaGFzT3duUHJvcGVydHkiLCJrIiwicGFyZW50U3ltYm9scyIsImdldE93blByb3BlcnR5U3ltYm9scyIsImkiLCJsZW5ndGgiLCJrcyIsImJrIiwiYmluZGluZ3NTeW1ib2xzIiwiYmkiLCJia3MiLCJjaGluZGluZ3MiLCJsb2ciLCJsZXZlbHMiLCJjdXN0b21MZXZlbHMiLCJyZWRhY3QiLCJBcnJheSIsImlzQXJyYXkiLCJzdHJpbmdpZmllcnMiLCJmb3JtYXRPcHRzIiwibXNnUHJlZml4IiwiY2hpbGRMZXZlbCIsIm9uQ2hpbGQiLCJjaGluZGluZ3NKc29uIiwic3Vic3RyIiwiYmluZGluZ3NGcm9tSnNvbiIsIkpTT04iLCJwYXJzZSIsInBpZCIsImhvc3RuYW1lIiwibmV3QmluZGluZ3MiLCJkZWZhdWx0TWl4aW5NZXJnZVN0cmF0ZWd5IiwibWVyZ2VPYmplY3QiLCJtaXhpbk9iamVjdCIsImFzc2lnbiIsIl9vYmoiLCJtc2ciLCJudW0iLCJ0IiwibWl4aW4iLCJlcnJvcktleSIsIm1lc3NhZ2VLZXkiLCJtaXhpbk1lcmdlU3RyYXRlZ3kiLCJvYmoiLCJzdHJlYW1Xcml0ZUhvb2siLCJzdHJlYW1Xcml0ZSIsInVuZGVmaW5lZCIsIm1lc3NhZ2UiLCJzIiwic3RyZWFtIiwibGFzdExldmVsIiwibGFzdE9iaiIsImxhc3RNc2ciLCJsYXN0VGltZSIsInNsaWNlIiwibGFzdExvZ2dlciIsIm5vb3AiLCJjYiJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/pino/lib/proto.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/pino/lib/redaction.js":
/*!********************************************!*\
  !*** ./node_modules/pino/lib/redaction.js ***!
  \********************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

eval("\nconst fastRedact = __webpack_require__(/*! fast-redact */ \"(ssr)/./node_modules/fast-redact/index.js\");\nconst { redactFmtSym, wildcardFirstSym } = __webpack_require__(/*! ./symbols */ \"(ssr)/./node_modules/pino/lib/symbols.js\");\nconst { rx, validator } = fastRedact;\nconst validate = validator({\n    ERR_PATHS_MUST_BE_STRINGS: ()=>\"pino  redacted paths must be strings\",\n    ERR_INVALID_PATH: (s)=>`pino  redact paths array contains an invalid path (${s})`\n});\nconst CENSOR = \"[Redacted]\";\nconst strict = false // TODO should this be configurable?\n;\nfunction redaction(opts, serialize) {\n    const { paths, censor } = handle(opts);\n    const shape = paths.reduce((o, str)=>{\n        rx.lastIndex = 0;\n        const first = rx.exec(str);\n        const next = rx.exec(str);\n        // ns is the top-level path segment, brackets + quoting removed.\n        let ns = first[1] !== undefined ? first[1].replace(/^(?:\"|'|`)(.*)(?:\"|'|`)$/, \"$1\") : first[0];\n        if (ns === \"*\") {\n            ns = wildcardFirstSym;\n        }\n        // top level key:\n        if (next === null) {\n            o[ns] = null;\n            return o;\n        }\n        // path with at least two segments:\n        // if ns is already redacted at the top level, ignore lower level redactions\n        if (o[ns] === null) {\n            return o;\n        }\n        const { index } = next;\n        const nextPath = `${str.substr(index, str.length - 1)}`;\n        o[ns] = o[ns] || [];\n        // shape is a mix of paths beginning with literal values and wildcard\n        // paths [ \"a.b.c\", \"*.b.z\" ] should reduce to a shape of\n        // { \"a\": [ \"b.c\", \"b.z\" ], *: [ \"b.z\" ] }\n        // note: \"b.z\" is in both \"a\" and * arrays because \"a\" matches the wildcard.\n        // (* entry has wildcardFirstSym as key)\n        if (ns !== wildcardFirstSym && o[ns].length === 0) {\n            // first time ns's get all '*' redactions so far\n            o[ns].push(...o[wildcardFirstSym] || []);\n        }\n        if (ns === wildcardFirstSym) {\n            // new * path gets added to all previously registered literal ns's.\n            Object.keys(o).forEach(function(k) {\n                if (o[k]) {\n                    o[k].push(nextPath);\n                }\n            });\n        }\n        o[ns].push(nextPath);\n        return o;\n    }, {});\n    // the redactor assigned to the format symbol key\n    // provides top level redaction for instances where\n    // an object is interpolated into the msg string\n    const result = {\n        [redactFmtSym]: fastRedact({\n            paths,\n            censor,\n            serialize,\n            strict\n        })\n    };\n    const topCensor = (...args)=>{\n        return typeof censor === \"function\" ? serialize(censor(...args)) : serialize(censor);\n    };\n    return [\n        ...Object.keys(shape),\n        ...Object.getOwnPropertySymbols(shape)\n    ].reduce((o, k)=>{\n        // top level key:\n        if (shape[k] === null) {\n            o[k] = (value)=>topCensor(value, [\n                    k\n                ]);\n        } else {\n            const wrappedCensor = typeof censor === \"function\" ? (value, path)=>{\n                return censor(value, [\n                    k,\n                    ...path\n                ]);\n            } : censor;\n            o[k] = fastRedact({\n                paths: shape[k],\n                censor: wrappedCensor,\n                serialize,\n                strict\n            });\n        }\n        return o;\n    }, result);\n}\nfunction handle(opts) {\n    if (Array.isArray(opts)) {\n        opts = {\n            paths: opts,\n            censor: CENSOR\n        };\n        validate(opts);\n        return opts;\n    }\n    let { paths, censor = CENSOR, remove } = opts;\n    if (Array.isArray(paths) === false) {\n        throw Error(\"pino  redact must contain an array of strings\");\n    }\n    if (remove === true) censor = undefined;\n    validate({\n        paths,\n        censor\n    });\n    return {\n        paths,\n        censor\n    };\n}\nmodule.exports = redaction;\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvcGluby9saWIvcmVkYWN0aW9uLmpzIiwibWFwcGluZ3MiOiJBQUFBO0FBRUEsTUFBTUEsYUFBYUMsbUJBQU9BLENBQUM7QUFDM0IsTUFBTSxFQUFFQyxZQUFZLEVBQUVDLGdCQUFnQixFQUFFLEdBQUdGLG1CQUFPQSxDQUFDO0FBQ25ELE1BQU0sRUFBRUcsRUFBRSxFQUFFQyxTQUFTLEVBQUUsR0FBR0w7QUFFMUIsTUFBTU0sV0FBV0QsVUFBVTtJQUN6QkUsMkJBQTJCLElBQU07SUFDakNDLGtCQUFrQixDQUFDQyxJQUFNLENBQUMsb0RBQW9ELEVBQUVBLEVBQUUsQ0FBQyxDQUFDO0FBQ3RGO0FBRUEsTUFBTUMsU0FBUztBQUNmLE1BQU1DLFNBQVMsTUFBTSxvQ0FBb0M7O0FBRXpELFNBQVNDLFVBQVdDLElBQUksRUFBRUMsU0FBUztJQUNqQyxNQUFNLEVBQUVDLEtBQUssRUFBRUMsTUFBTSxFQUFFLEdBQUdDLE9BQU9KO0lBRWpDLE1BQU1LLFFBQVFILE1BQU1JLE1BQU0sQ0FBQyxDQUFDQyxHQUFHQztRQUM3QmpCLEdBQUdrQixTQUFTLEdBQUc7UUFDZixNQUFNQyxRQUFRbkIsR0FBR29CLElBQUksQ0FBQ0g7UUFDdEIsTUFBTUksT0FBT3JCLEdBQUdvQixJQUFJLENBQUNIO1FBRXJCLGdFQUFnRTtRQUNoRSxJQUFJSyxLQUFLSCxLQUFLLENBQUMsRUFBRSxLQUFLSSxZQUNsQkosS0FBSyxDQUFDLEVBQUUsQ0FBQ0ssT0FBTyxDQUFDLDRCQUE0QixRQUM3Q0wsS0FBSyxDQUFDLEVBQUU7UUFFWixJQUFJRyxPQUFPLEtBQUs7WUFDZEEsS0FBS3ZCO1FBQ1A7UUFFQSxpQkFBaUI7UUFDakIsSUFBSXNCLFNBQVMsTUFBTTtZQUNqQkwsQ0FBQyxDQUFDTSxHQUFHLEdBQUc7WUFDUixPQUFPTjtRQUNUO1FBRUEsbUNBQW1DO1FBQ25DLDRFQUE0RTtRQUM1RSxJQUFJQSxDQUFDLENBQUNNLEdBQUcsS0FBSyxNQUFNO1lBQ2xCLE9BQU9OO1FBQ1Q7UUFFQSxNQUFNLEVBQUVTLEtBQUssRUFBRSxHQUFHSjtRQUNsQixNQUFNSyxXQUFXLENBQUMsRUFBRVQsSUFBSVUsTUFBTSxDQUFDRixPQUFPUixJQUFJVyxNQUFNLEdBQUcsR0FBRyxDQUFDO1FBRXZEWixDQUFDLENBQUNNLEdBQUcsR0FBR04sQ0FBQyxDQUFDTSxHQUFHLElBQUksRUFBRTtRQUVuQixxRUFBcUU7UUFDckUseURBQXlEO1FBQ3pELDBDQUEwQztRQUMxQyw0RUFBNEU7UUFDNUUsd0NBQXdDO1FBQ3hDLElBQUlBLE9BQU92QixvQkFBb0JpQixDQUFDLENBQUNNLEdBQUcsQ0FBQ00sTUFBTSxLQUFLLEdBQUc7WUFDakQsZ0RBQWdEO1lBQ2hEWixDQUFDLENBQUNNLEdBQUcsQ0FBQ08sSUFBSSxJQUFLYixDQUFDLENBQUNqQixpQkFBaUIsSUFBSSxFQUFFO1FBQzFDO1FBRUEsSUFBSXVCLE9BQU92QixrQkFBa0I7WUFDM0IsbUVBQW1FO1lBQ25FK0IsT0FBT0MsSUFBSSxDQUFDZixHQUFHZ0IsT0FBTyxDQUFDLFNBQVVDLENBQUM7Z0JBQ2hDLElBQUlqQixDQUFDLENBQUNpQixFQUFFLEVBQUU7b0JBQ1JqQixDQUFDLENBQUNpQixFQUFFLENBQUNKLElBQUksQ0FBQ0g7Z0JBQ1o7WUFDRjtRQUNGO1FBRUFWLENBQUMsQ0FBQ00sR0FBRyxDQUFDTyxJQUFJLENBQUNIO1FBQ1gsT0FBT1Y7SUFDVCxHQUFHLENBQUM7SUFFSixpREFBaUQ7SUFDakQsbURBQW1EO0lBQ25ELGdEQUFnRDtJQUNoRCxNQUFNa0IsU0FBUztRQUNiLENBQUNwQyxhQUFhLEVBQUVGLFdBQVc7WUFBRWU7WUFBT0M7WUFBUUY7WUFBV0g7UUFBTztJQUNoRTtJQUVBLE1BQU00QixZQUFZLENBQUMsR0FBR0M7UUFDcEIsT0FBTyxPQUFPeEIsV0FBVyxhQUFhRixVQUFVRSxVQUFVd0IsU0FBUzFCLFVBQVVFO0lBQy9FO0lBRUEsT0FBTztXQUFJa0IsT0FBT0MsSUFBSSxDQUFDakI7V0FBV2dCLE9BQU9PLHFCQUFxQixDQUFDdkI7S0FBTyxDQUFDQyxNQUFNLENBQUMsQ0FBQ0MsR0FBR2lCO1FBQ2hGLGlCQUFpQjtRQUNqQixJQUFJbkIsS0FBSyxDQUFDbUIsRUFBRSxLQUFLLE1BQU07WUFDckJqQixDQUFDLENBQUNpQixFQUFFLEdBQUcsQ0FBQ0ssUUFBVUgsVUFBVUcsT0FBTztvQkFBQ0w7aUJBQUU7UUFDeEMsT0FBTztZQUNMLE1BQU1NLGdCQUFnQixPQUFPM0IsV0FBVyxhQUNwQyxDQUFDMEIsT0FBT0U7Z0JBQ04sT0FBTzVCLE9BQU8wQixPQUFPO29CQUFDTDt1QkFBTU87aUJBQUs7WUFDbkMsSUFDQTVCO1lBQ0pJLENBQUMsQ0FBQ2lCLEVBQUUsR0FBR3JDLFdBQVc7Z0JBQ2hCZSxPQUFPRyxLQUFLLENBQUNtQixFQUFFO2dCQUNmckIsUUFBUTJCO2dCQUNSN0I7Z0JBQ0FIO1lBQ0Y7UUFDRjtRQUNBLE9BQU9TO0lBQ1QsR0FBR2tCO0FBQ0w7QUFFQSxTQUFTckIsT0FBUUosSUFBSTtJQUNuQixJQUFJZ0MsTUFBTUMsT0FBTyxDQUFDakMsT0FBTztRQUN2QkEsT0FBTztZQUFFRSxPQUFPRjtZQUFNRyxRQUFRTjtRQUFPO1FBQ3JDSixTQUFTTztRQUNULE9BQU9BO0lBQ1Q7SUFDQSxJQUFJLEVBQUVFLEtBQUssRUFBRUMsU0FBU04sTUFBTSxFQUFFcUMsTUFBTSxFQUFFLEdBQUdsQztJQUN6QyxJQUFJZ0MsTUFBTUMsT0FBTyxDQUFDL0IsV0FBVyxPQUFPO1FBQUUsTUFBTWlDLE1BQU07SUFBa0Q7SUFDcEcsSUFBSUQsV0FBVyxNQUFNL0IsU0FBU1c7SUFDOUJyQixTQUFTO1FBQUVTO1FBQU9DO0lBQU87SUFFekIsT0FBTztRQUFFRDtRQUFPQztJQUFPO0FBQ3pCO0FBRUFpQyxPQUFPQyxPQUFPLEdBQUd0QyIsInNvdXJjZXMiOlsid2VicGFjazovL25leHQtYWRtaW4tZGFzaGJvYXJkLy4vbm9kZV9tb2R1bGVzL3Bpbm8vbGliL3JlZGFjdGlvbi5qcz9jODQ2Il0sInNvdXJjZXNDb250ZW50IjpbIid1c2Ugc3RyaWN0J1xuXG5jb25zdCBmYXN0UmVkYWN0ID0gcmVxdWlyZSgnZmFzdC1yZWRhY3QnKVxuY29uc3QgeyByZWRhY3RGbXRTeW0sIHdpbGRjYXJkRmlyc3RTeW0gfSA9IHJlcXVpcmUoJy4vc3ltYm9scycpXG5jb25zdCB7IHJ4LCB2YWxpZGF0b3IgfSA9IGZhc3RSZWRhY3RcblxuY29uc3QgdmFsaWRhdGUgPSB2YWxpZGF0b3Ioe1xuICBFUlJfUEFUSFNfTVVTVF9CRV9TVFJJTkdTOiAoKSA9PiAncGlubyDigJMgcmVkYWN0ZWQgcGF0aHMgbXVzdCBiZSBzdHJpbmdzJyxcbiAgRVJSX0lOVkFMSURfUEFUSDogKHMpID0+IGBwaW5vIOKAkyByZWRhY3QgcGF0aHMgYXJyYXkgY29udGFpbnMgYW4gaW52YWxpZCBwYXRoICgke3N9KWBcbn0pXG5cbmNvbnN0IENFTlNPUiA9ICdbUmVkYWN0ZWRdJ1xuY29uc3Qgc3RyaWN0ID0gZmFsc2UgLy8gVE9ETyBzaG91bGQgdGhpcyBiZSBjb25maWd1cmFibGU/XG5cbmZ1bmN0aW9uIHJlZGFjdGlvbiAob3B0cywgc2VyaWFsaXplKSB7XG4gIGNvbnN0IHsgcGF0aHMsIGNlbnNvciB9ID0gaGFuZGxlKG9wdHMpXG5cbiAgY29uc3Qgc2hhcGUgPSBwYXRocy5yZWR1Y2UoKG8sIHN0cikgPT4ge1xuICAgIHJ4Lmxhc3RJbmRleCA9IDBcbiAgICBjb25zdCBmaXJzdCA9IHJ4LmV4ZWMoc3RyKVxuICAgIGNvbnN0IG5leHQgPSByeC5leGVjKHN0cilcblxuICAgIC8vIG5zIGlzIHRoZSB0b3AtbGV2ZWwgcGF0aCBzZWdtZW50LCBicmFja2V0cyArIHF1b3RpbmcgcmVtb3ZlZC5cbiAgICBsZXQgbnMgPSBmaXJzdFsxXSAhPT0gdW5kZWZpbmVkXG4gICAgICA/IGZpcnN0WzFdLnJlcGxhY2UoL14oPzpcInwnfGApKC4qKSg/OlwifCd8YCkkLywgJyQxJylcbiAgICAgIDogZmlyc3RbMF1cblxuICAgIGlmIChucyA9PT0gJyonKSB7XG4gICAgICBucyA9IHdpbGRjYXJkRmlyc3RTeW1cbiAgICB9XG5cbiAgICAvLyB0b3AgbGV2ZWwga2V5OlxuICAgIGlmIChuZXh0ID09PSBudWxsKSB7XG4gICAgICBvW25zXSA9IG51bGxcbiAgICAgIHJldHVybiBvXG4gICAgfVxuXG4gICAgLy8gcGF0aCB3aXRoIGF0IGxlYXN0IHR3byBzZWdtZW50czpcbiAgICAvLyBpZiBucyBpcyBhbHJlYWR5IHJlZGFjdGVkIGF0IHRoZSB0b3AgbGV2ZWwsIGlnbm9yZSBsb3dlciBsZXZlbCByZWRhY3Rpb25zXG4gICAgaWYgKG9bbnNdID09PSBudWxsKSB7XG4gICAgICByZXR1cm4gb1xuICAgIH1cblxuICAgIGNvbnN0IHsgaW5kZXggfSA9IG5leHRcbiAgICBjb25zdCBuZXh0UGF0aCA9IGAke3N0ci5zdWJzdHIoaW5kZXgsIHN0ci5sZW5ndGggLSAxKX1gXG5cbiAgICBvW25zXSA9IG9bbnNdIHx8IFtdXG5cbiAgICAvLyBzaGFwZSBpcyBhIG1peCBvZiBwYXRocyBiZWdpbm5pbmcgd2l0aCBsaXRlcmFsIHZhbHVlcyBhbmQgd2lsZGNhcmRcbiAgICAvLyBwYXRocyBbIFwiYS5iLmNcIiwgXCIqLmIuelwiIF0gc2hvdWxkIHJlZHVjZSB0byBhIHNoYXBlIG9mXG4gICAgLy8geyBcImFcIjogWyBcImIuY1wiLCBcImIuelwiIF0sICo6IFsgXCJiLnpcIiBdIH1cbiAgICAvLyBub3RlOiBcImIuelwiIGlzIGluIGJvdGggXCJhXCIgYW5kICogYXJyYXlzIGJlY2F1c2UgXCJhXCIgbWF0Y2hlcyB0aGUgd2lsZGNhcmQuXG4gICAgLy8gKCogZW50cnkgaGFzIHdpbGRjYXJkRmlyc3RTeW0gYXMga2V5KVxuICAgIGlmIChucyAhPT0gd2lsZGNhcmRGaXJzdFN5bSAmJiBvW25zXS5sZW5ndGggPT09IDApIHtcbiAgICAgIC8vIGZpcnN0IHRpbWUgbnMncyBnZXQgYWxsICcqJyByZWRhY3Rpb25zIHNvIGZhclxuICAgICAgb1tuc10ucHVzaCguLi4ob1t3aWxkY2FyZEZpcnN0U3ltXSB8fCBbXSkpXG4gICAgfVxuXG4gICAgaWYgKG5zID09PSB3aWxkY2FyZEZpcnN0U3ltKSB7XG4gICAgICAvLyBuZXcgKiBwYXRoIGdldHMgYWRkZWQgdG8gYWxsIHByZXZpb3VzbHkgcmVnaXN0ZXJlZCBsaXRlcmFsIG5zJ3MuXG4gICAgICBPYmplY3Qua2V5cyhvKS5mb3JFYWNoKGZ1bmN0aW9uIChrKSB7XG4gICAgICAgIGlmIChvW2tdKSB7XG4gICAgICAgICAgb1trXS5wdXNoKG5leHRQYXRoKVxuICAgICAgICB9XG4gICAgICB9KVxuICAgIH1cblxuICAgIG9bbnNdLnB1c2gobmV4dFBhdGgpXG4gICAgcmV0dXJuIG9cbiAgfSwge30pXG5cbiAgLy8gdGhlIHJlZGFjdG9yIGFzc2lnbmVkIHRvIHRoZSBmb3JtYXQgc3ltYm9sIGtleVxuICAvLyBwcm92aWRlcyB0b3AgbGV2ZWwgcmVkYWN0aW9uIGZvciBpbnN0YW5jZXMgd2hlcmVcbiAgLy8gYW4gb2JqZWN0IGlzIGludGVycG9sYXRlZCBpbnRvIHRoZSBtc2cgc3RyaW5nXG4gIGNvbnN0IHJlc3VsdCA9IHtcbiAgICBbcmVkYWN0Rm10U3ltXTogZmFzdFJlZGFjdCh7IHBhdGhzLCBjZW5zb3IsIHNlcmlhbGl6ZSwgc3RyaWN0IH0pXG4gIH1cblxuICBjb25zdCB0b3BDZW5zb3IgPSAoLi4uYXJncykgPT4ge1xuICAgIHJldHVybiB0eXBlb2YgY2Vuc29yID09PSAnZnVuY3Rpb24nID8gc2VyaWFsaXplKGNlbnNvciguLi5hcmdzKSkgOiBzZXJpYWxpemUoY2Vuc29yKVxuICB9XG5cbiAgcmV0dXJuIFsuLi5PYmplY3Qua2V5cyhzaGFwZSksIC4uLk9iamVjdC5nZXRPd25Qcm9wZXJ0eVN5bWJvbHMoc2hhcGUpXS5yZWR1Y2UoKG8sIGspID0+IHtcbiAgICAvLyB0b3AgbGV2ZWwga2V5OlxuICAgIGlmIChzaGFwZVtrXSA9PT0gbnVsbCkge1xuICAgICAgb1trXSA9ICh2YWx1ZSkgPT4gdG9wQ2Vuc29yKHZhbHVlLCBba10pXG4gICAgfSBlbHNlIHtcbiAgICAgIGNvbnN0IHdyYXBwZWRDZW5zb3IgPSB0eXBlb2YgY2Vuc29yID09PSAnZnVuY3Rpb24nXG4gICAgICAgID8gKHZhbHVlLCBwYXRoKSA9PiB7XG4gICAgICAgICAgICByZXR1cm4gY2Vuc29yKHZhbHVlLCBbaywgLi4ucGF0aF0pXG4gICAgICAgICAgfVxuICAgICAgICA6IGNlbnNvclxuICAgICAgb1trXSA9IGZhc3RSZWRhY3Qoe1xuICAgICAgICBwYXRoczogc2hhcGVba10sXG4gICAgICAgIGNlbnNvcjogd3JhcHBlZENlbnNvcixcbiAgICAgICAgc2VyaWFsaXplLFxuICAgICAgICBzdHJpY3RcbiAgICAgIH0pXG4gICAgfVxuICAgIHJldHVybiBvXG4gIH0sIHJlc3VsdClcbn1cblxuZnVuY3Rpb24gaGFuZGxlIChvcHRzKSB7XG4gIGlmIChBcnJheS5pc0FycmF5KG9wdHMpKSB7XG4gICAgb3B0cyA9IHsgcGF0aHM6IG9wdHMsIGNlbnNvcjogQ0VOU09SIH1cbiAgICB2YWxpZGF0ZShvcHRzKVxuICAgIHJldHVybiBvcHRzXG4gIH1cbiAgbGV0IHsgcGF0aHMsIGNlbnNvciA9IENFTlNPUiwgcmVtb3ZlIH0gPSBvcHRzXG4gIGlmIChBcnJheS5pc0FycmF5KHBhdGhzKSA9PT0gZmFsc2UpIHsgdGhyb3cgRXJyb3IoJ3Bpbm8g4oCTIHJlZGFjdCBtdXN0IGNvbnRhaW4gYW4gYXJyYXkgb2Ygc3RyaW5ncycpIH1cbiAgaWYgKHJlbW92ZSA9PT0gdHJ1ZSkgY2Vuc29yID0gdW5kZWZpbmVkXG4gIHZhbGlkYXRlKHsgcGF0aHMsIGNlbnNvciB9KVxuXG4gIHJldHVybiB7IHBhdGhzLCBjZW5zb3IgfVxufVxuXG5tb2R1bGUuZXhwb3J0cyA9IHJlZGFjdGlvblxuIl0sIm5hbWVzIjpbImZhc3RSZWRhY3QiLCJyZXF1aXJlIiwicmVkYWN0Rm10U3ltIiwid2lsZGNhcmRGaXJzdFN5bSIsInJ4IiwidmFsaWRhdG9yIiwidmFsaWRhdGUiLCJFUlJfUEFUSFNfTVVTVF9CRV9TVFJJTkdTIiwiRVJSX0lOVkFMSURfUEFUSCIsInMiLCJDRU5TT1IiLCJzdHJpY3QiLCJyZWRhY3Rpb24iLCJvcHRzIiwic2VyaWFsaXplIiwicGF0aHMiLCJjZW5zb3IiLCJoYW5kbGUiLCJzaGFwZSIsInJlZHVjZSIsIm8iLCJzdHIiLCJsYXN0SW5kZXgiLCJmaXJzdCIsImV4ZWMiLCJuZXh0IiwibnMiLCJ1bmRlZmluZWQiLCJyZXBsYWNlIiwiaW5kZXgiLCJuZXh0UGF0aCIsInN1YnN0ciIsImxlbmd0aCIsInB1c2giLCJPYmplY3QiLCJrZXlzIiwiZm9yRWFjaCIsImsiLCJyZXN1bHQiLCJ0b3BDZW5zb3IiLCJhcmdzIiwiZ2V0T3duUHJvcGVydHlTeW1ib2xzIiwidmFsdWUiLCJ3cmFwcGVkQ2Vuc29yIiwicGF0aCIsIkFycmF5IiwiaXNBcnJheSIsInJlbW92ZSIsIkVycm9yIiwibW9kdWxlIiwiZXhwb3J0cyJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/pino/lib/redaction.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/pino/lib/symbols.js":
/*!******************************************!*\
  !*** ./node_modules/pino/lib/symbols.js ***!
  \******************************************/
/***/ ((module) => {

eval("\nconst setLevelSym = Symbol(\"pino.setLevel\");\nconst getLevelSym = Symbol(\"pino.getLevel\");\nconst levelValSym = Symbol(\"pino.levelVal\");\nconst levelCompSym = Symbol(\"pino.levelComp\");\nconst useLevelLabelsSym = Symbol(\"pino.useLevelLabels\");\nconst useOnlyCustomLevelsSym = Symbol(\"pino.useOnlyCustomLevels\");\nconst mixinSym = Symbol(\"pino.mixin\");\nconst lsCacheSym = Symbol(\"pino.lsCache\");\nconst chindingsSym = Symbol(\"pino.chindings\");\nconst asJsonSym = Symbol(\"pino.asJson\");\nconst writeSym = Symbol(\"pino.write\");\nconst redactFmtSym = Symbol(\"pino.redactFmt\");\nconst timeSym = Symbol(\"pino.time\");\nconst timeSliceIndexSym = Symbol(\"pino.timeSliceIndex\");\nconst streamSym = Symbol(\"pino.stream\");\nconst stringifySym = Symbol(\"pino.stringify\");\nconst stringifySafeSym = Symbol(\"pino.stringifySafe\");\nconst stringifiersSym = Symbol(\"pino.stringifiers\");\nconst endSym = Symbol(\"pino.end\");\nconst formatOptsSym = Symbol(\"pino.formatOpts\");\nconst messageKeySym = Symbol(\"pino.messageKey\");\nconst errorKeySym = Symbol(\"pino.errorKey\");\nconst nestedKeySym = Symbol(\"pino.nestedKey\");\nconst nestedKeyStrSym = Symbol(\"pino.nestedKeyStr\");\nconst mixinMergeStrategySym = Symbol(\"pino.mixinMergeStrategy\");\nconst msgPrefixSym = Symbol(\"pino.msgPrefix\");\nconst wildcardFirstSym = Symbol(\"pino.wildcardFirst\");\n// public symbols, no need to use the same pino\n// version for these\nconst serializersSym = Symbol.for(\"pino.serializers\");\nconst formattersSym = Symbol.for(\"pino.formatters\");\nconst hooksSym = Symbol.for(\"pino.hooks\");\nconst needsMetadataGsym = Symbol.for(\"pino.metadata\");\nmodule.exports = {\n    setLevelSym,\n    getLevelSym,\n    levelValSym,\n    levelCompSym,\n    useLevelLabelsSym,\n    mixinSym,\n    lsCacheSym,\n    chindingsSym,\n    asJsonSym,\n    writeSym,\n    serializersSym,\n    redactFmtSym,\n    timeSym,\n    timeSliceIndexSym,\n    streamSym,\n    stringifySym,\n    stringifySafeSym,\n    stringifiersSym,\n    endSym,\n    formatOptsSym,\n    messageKeySym,\n    errorKeySym,\n    nestedKeySym,\n    wildcardFirstSym,\n    needsMetadataGsym,\n    useOnlyCustomLevelsSym,\n    formattersSym,\n    hooksSym,\n    nestedKeyStrSym,\n    mixinMergeStrategySym,\n    msgPrefixSym\n};\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvcGluby9saWIvc3ltYm9scy5qcyIsIm1hcHBpbmdzIjoiQUFBQTtBQUVBLE1BQU1BLGNBQWNDLE9BQU87QUFDM0IsTUFBTUMsY0FBY0QsT0FBTztBQUMzQixNQUFNRSxjQUFjRixPQUFPO0FBQzNCLE1BQU1HLGVBQWVILE9BQU87QUFDNUIsTUFBTUksb0JBQW9CSixPQUFPO0FBQ2pDLE1BQU1LLHlCQUF5QkwsT0FBTztBQUN0QyxNQUFNTSxXQUFXTixPQUFPO0FBRXhCLE1BQU1PLGFBQWFQLE9BQU87QUFDMUIsTUFBTVEsZUFBZVIsT0FBTztBQUU1QixNQUFNUyxZQUFZVCxPQUFPO0FBQ3pCLE1BQU1VLFdBQVdWLE9BQU87QUFDeEIsTUFBTVcsZUFBZVgsT0FBTztBQUU1QixNQUFNWSxVQUFVWixPQUFPO0FBQ3ZCLE1BQU1hLG9CQUFvQmIsT0FBTztBQUNqQyxNQUFNYyxZQUFZZCxPQUFPO0FBQ3pCLE1BQU1lLGVBQWVmLE9BQU87QUFDNUIsTUFBTWdCLG1CQUFtQmhCLE9BQU87QUFDaEMsTUFBTWlCLGtCQUFrQmpCLE9BQU87QUFDL0IsTUFBTWtCLFNBQVNsQixPQUFPO0FBQ3RCLE1BQU1tQixnQkFBZ0JuQixPQUFPO0FBQzdCLE1BQU1vQixnQkFBZ0JwQixPQUFPO0FBQzdCLE1BQU1xQixjQUFjckIsT0FBTztBQUMzQixNQUFNc0IsZUFBZXRCLE9BQU87QUFDNUIsTUFBTXVCLGtCQUFrQnZCLE9BQU87QUFDL0IsTUFBTXdCLHdCQUF3QnhCLE9BQU87QUFDckMsTUFBTXlCLGVBQWV6QixPQUFPO0FBRTVCLE1BQU0wQixtQkFBbUIxQixPQUFPO0FBRWhDLCtDQUErQztBQUMvQyxvQkFBb0I7QUFDcEIsTUFBTTJCLGlCQUFpQjNCLE9BQU80QixHQUFHLENBQUM7QUFDbEMsTUFBTUMsZ0JBQWdCN0IsT0FBTzRCLEdBQUcsQ0FBQztBQUNqQyxNQUFNRSxXQUFXOUIsT0FBTzRCLEdBQUcsQ0FBQztBQUM1QixNQUFNRyxvQkFBb0IvQixPQUFPNEIsR0FBRyxDQUFDO0FBRXJDSSxPQUFPQyxPQUFPLEdBQUc7SUFDZmxDO0lBQ0FFO0lBQ0FDO0lBQ0FDO0lBQ0FDO0lBQ0FFO0lBQ0FDO0lBQ0FDO0lBQ0FDO0lBQ0FDO0lBQ0FpQjtJQUNBaEI7SUFDQUM7SUFDQUM7SUFDQUM7SUFDQUM7SUFDQUM7SUFDQUM7SUFDQUM7SUFDQUM7SUFDQUM7SUFDQUM7SUFDQUM7SUFDQUk7SUFDQUs7SUFDQTFCO0lBQ0F3QjtJQUNBQztJQUNBUDtJQUNBQztJQUNBQztBQUNGIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vbmV4dC1hZG1pbi1kYXNoYm9hcmQvLi9ub2RlX21vZHVsZXMvcGluby9saWIvc3ltYm9scy5qcz83ZTAyIl0sInNvdXJjZXNDb250ZW50IjpbIid1c2Ugc3RyaWN0J1xuXG5jb25zdCBzZXRMZXZlbFN5bSA9IFN5bWJvbCgncGluby5zZXRMZXZlbCcpXG5jb25zdCBnZXRMZXZlbFN5bSA9IFN5bWJvbCgncGluby5nZXRMZXZlbCcpXG5jb25zdCBsZXZlbFZhbFN5bSA9IFN5bWJvbCgncGluby5sZXZlbFZhbCcpXG5jb25zdCBsZXZlbENvbXBTeW0gPSBTeW1ib2woJ3Bpbm8ubGV2ZWxDb21wJylcbmNvbnN0IHVzZUxldmVsTGFiZWxzU3ltID0gU3ltYm9sKCdwaW5vLnVzZUxldmVsTGFiZWxzJylcbmNvbnN0IHVzZU9ubHlDdXN0b21MZXZlbHNTeW0gPSBTeW1ib2woJ3Bpbm8udXNlT25seUN1c3RvbUxldmVscycpXG5jb25zdCBtaXhpblN5bSA9IFN5bWJvbCgncGluby5taXhpbicpXG5cbmNvbnN0IGxzQ2FjaGVTeW0gPSBTeW1ib2woJ3Bpbm8ubHNDYWNoZScpXG5jb25zdCBjaGluZGluZ3NTeW0gPSBTeW1ib2woJ3Bpbm8uY2hpbmRpbmdzJylcblxuY29uc3QgYXNKc29uU3ltID0gU3ltYm9sKCdwaW5vLmFzSnNvbicpXG5jb25zdCB3cml0ZVN5bSA9IFN5bWJvbCgncGluby53cml0ZScpXG5jb25zdCByZWRhY3RGbXRTeW0gPSBTeW1ib2woJ3Bpbm8ucmVkYWN0Rm10JylcblxuY29uc3QgdGltZVN5bSA9IFN5bWJvbCgncGluby50aW1lJylcbmNvbnN0IHRpbWVTbGljZUluZGV4U3ltID0gU3ltYm9sKCdwaW5vLnRpbWVTbGljZUluZGV4JylcbmNvbnN0IHN0cmVhbVN5bSA9IFN5bWJvbCgncGluby5zdHJlYW0nKVxuY29uc3Qgc3RyaW5naWZ5U3ltID0gU3ltYm9sKCdwaW5vLnN0cmluZ2lmeScpXG5jb25zdCBzdHJpbmdpZnlTYWZlU3ltID0gU3ltYm9sKCdwaW5vLnN0cmluZ2lmeVNhZmUnKVxuY29uc3Qgc3RyaW5naWZpZXJzU3ltID0gU3ltYm9sKCdwaW5vLnN0cmluZ2lmaWVycycpXG5jb25zdCBlbmRTeW0gPSBTeW1ib2woJ3Bpbm8uZW5kJylcbmNvbnN0IGZvcm1hdE9wdHNTeW0gPSBTeW1ib2woJ3Bpbm8uZm9ybWF0T3B0cycpXG5jb25zdCBtZXNzYWdlS2V5U3ltID0gU3ltYm9sKCdwaW5vLm1lc3NhZ2VLZXknKVxuY29uc3QgZXJyb3JLZXlTeW0gPSBTeW1ib2woJ3Bpbm8uZXJyb3JLZXknKVxuY29uc3QgbmVzdGVkS2V5U3ltID0gU3ltYm9sKCdwaW5vLm5lc3RlZEtleScpXG5jb25zdCBuZXN0ZWRLZXlTdHJTeW0gPSBTeW1ib2woJ3Bpbm8ubmVzdGVkS2V5U3RyJylcbmNvbnN0IG1peGluTWVyZ2VTdHJhdGVneVN5bSA9IFN5bWJvbCgncGluby5taXhpbk1lcmdlU3RyYXRlZ3knKVxuY29uc3QgbXNnUHJlZml4U3ltID0gU3ltYm9sKCdwaW5vLm1zZ1ByZWZpeCcpXG5cbmNvbnN0IHdpbGRjYXJkRmlyc3RTeW0gPSBTeW1ib2woJ3Bpbm8ud2lsZGNhcmRGaXJzdCcpXG5cbi8vIHB1YmxpYyBzeW1ib2xzLCBubyBuZWVkIHRvIHVzZSB0aGUgc2FtZSBwaW5vXG4vLyB2ZXJzaW9uIGZvciB0aGVzZVxuY29uc3Qgc2VyaWFsaXplcnNTeW0gPSBTeW1ib2wuZm9yKCdwaW5vLnNlcmlhbGl6ZXJzJylcbmNvbnN0IGZvcm1hdHRlcnNTeW0gPSBTeW1ib2wuZm9yKCdwaW5vLmZvcm1hdHRlcnMnKVxuY29uc3QgaG9va3NTeW0gPSBTeW1ib2wuZm9yKCdwaW5vLmhvb2tzJylcbmNvbnN0IG5lZWRzTWV0YWRhdGFHc3ltID0gU3ltYm9sLmZvcigncGluby5tZXRhZGF0YScpXG5cbm1vZHVsZS5leHBvcnRzID0ge1xuICBzZXRMZXZlbFN5bSxcbiAgZ2V0TGV2ZWxTeW0sXG4gIGxldmVsVmFsU3ltLFxuICBsZXZlbENvbXBTeW0sXG4gIHVzZUxldmVsTGFiZWxzU3ltLFxuICBtaXhpblN5bSxcbiAgbHNDYWNoZVN5bSxcbiAgY2hpbmRpbmdzU3ltLFxuICBhc0pzb25TeW0sXG4gIHdyaXRlU3ltLFxuICBzZXJpYWxpemVyc1N5bSxcbiAgcmVkYWN0Rm10U3ltLFxuICB0aW1lU3ltLFxuICB0aW1lU2xpY2VJbmRleFN5bSxcbiAgc3RyZWFtU3ltLFxuICBzdHJpbmdpZnlTeW0sXG4gIHN0cmluZ2lmeVNhZmVTeW0sXG4gIHN0cmluZ2lmaWVyc1N5bSxcbiAgZW5kU3ltLFxuICBmb3JtYXRPcHRzU3ltLFxuICBtZXNzYWdlS2V5U3ltLFxuICBlcnJvcktleVN5bSxcbiAgbmVzdGVkS2V5U3ltLFxuICB3aWxkY2FyZEZpcnN0U3ltLFxuICBuZWVkc01ldGFkYXRhR3N5bSxcbiAgdXNlT25seUN1c3RvbUxldmVsc1N5bSxcbiAgZm9ybWF0dGVyc1N5bSxcbiAgaG9va3NTeW0sXG4gIG5lc3RlZEtleVN0clN5bSxcbiAgbWl4aW5NZXJnZVN0cmF0ZWd5U3ltLFxuICBtc2dQcmVmaXhTeW1cbn1cbiJdLCJuYW1lcyI6WyJzZXRMZXZlbFN5bSIsIlN5bWJvbCIsImdldExldmVsU3ltIiwibGV2ZWxWYWxTeW0iLCJsZXZlbENvbXBTeW0iLCJ1c2VMZXZlbExhYmVsc1N5bSIsInVzZU9ubHlDdXN0b21MZXZlbHNTeW0iLCJtaXhpblN5bSIsImxzQ2FjaGVTeW0iLCJjaGluZGluZ3NTeW0iLCJhc0pzb25TeW0iLCJ3cml0ZVN5bSIsInJlZGFjdEZtdFN5bSIsInRpbWVTeW0iLCJ0aW1lU2xpY2VJbmRleFN5bSIsInN0cmVhbVN5bSIsInN0cmluZ2lmeVN5bSIsInN0cmluZ2lmeVNhZmVTeW0iLCJzdHJpbmdpZmllcnNTeW0iLCJlbmRTeW0iLCJmb3JtYXRPcHRzU3ltIiwibWVzc2FnZUtleVN5bSIsImVycm9yS2V5U3ltIiwibmVzdGVkS2V5U3ltIiwibmVzdGVkS2V5U3RyU3ltIiwibWl4aW5NZXJnZVN0cmF0ZWd5U3ltIiwibXNnUHJlZml4U3ltIiwid2lsZGNhcmRGaXJzdFN5bSIsInNlcmlhbGl6ZXJzU3ltIiwiZm9yIiwiZm9ybWF0dGVyc1N5bSIsImhvb2tzU3ltIiwibmVlZHNNZXRhZGF0YUdzeW0iLCJtb2R1bGUiLCJleHBvcnRzIl0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/pino/lib/symbols.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/pino/lib/time.js":
/*!***************************************!*\
  !*** ./node_modules/pino/lib/time.js ***!
  \***************************************/
/***/ ((module) => {

eval("\nconst nullTime = ()=>\"\";\nconst epochTime = ()=>`,\"time\":${Date.now()}`;\nconst unixTime = ()=>`,\"time\":${Math.round(Date.now() / 1000.0)}`;\nconst isoTime = ()=>`,\"time\":\"${new Date(Date.now()).toISOString()}\"` // using Date.now() for testability\n;\nmodule.exports = {\n    nullTime,\n    epochTime,\n    unixTime,\n    isoTime\n};\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvcGluby9saWIvdGltZS5qcyIsIm1hcHBpbmdzIjoiQUFBQTtBQUVBLE1BQU1BLFdBQVcsSUFBTTtBQUV2QixNQUFNQyxZQUFZLElBQU0sQ0FBQyxRQUFRLEVBQUVDLEtBQUtDLEdBQUcsR0FBRyxDQUFDO0FBRS9DLE1BQU1DLFdBQVcsSUFBTSxDQUFDLFFBQVEsRUFBRUMsS0FBS0MsS0FBSyxDQUFDSixLQUFLQyxHQUFHLEtBQUssUUFBUSxDQUFDO0FBRW5FLE1BQU1JLFVBQVUsSUFBTSxDQUFDLFNBQVMsRUFBRSxJQUFJTCxLQUFLQSxLQUFLQyxHQUFHLElBQUlLLFdBQVcsR0FBRyxDQUFDLENBQUMsQ0FBQyxtQ0FBbUM7O0FBRTNHQyxPQUFPQyxPQUFPLEdBQUc7SUFBRVY7SUFBVUM7SUFBV0c7SUFBVUc7QUFBUSIsInNvdXJjZXMiOlsid2VicGFjazovL25leHQtYWRtaW4tZGFzaGJvYXJkLy4vbm9kZV9tb2R1bGVzL3Bpbm8vbGliL3RpbWUuanM/NDEzNiJdLCJzb3VyY2VzQ29udGVudCI6WyIndXNlIHN0cmljdCdcblxuY29uc3QgbnVsbFRpbWUgPSAoKSA9PiAnJ1xuXG5jb25zdCBlcG9jaFRpbWUgPSAoKSA9PiBgLFwidGltZVwiOiR7RGF0ZS5ub3coKX1gXG5cbmNvbnN0IHVuaXhUaW1lID0gKCkgPT4gYCxcInRpbWVcIjoke01hdGgucm91bmQoRGF0ZS5ub3coKSAvIDEwMDAuMCl9YFxuXG5jb25zdCBpc29UaW1lID0gKCkgPT4gYCxcInRpbWVcIjpcIiR7bmV3IERhdGUoRGF0ZS5ub3coKSkudG9JU09TdHJpbmcoKX1cImAgLy8gdXNpbmcgRGF0ZS5ub3coKSBmb3IgdGVzdGFiaWxpdHlcblxubW9kdWxlLmV4cG9ydHMgPSB7IG51bGxUaW1lLCBlcG9jaFRpbWUsIHVuaXhUaW1lLCBpc29UaW1lIH1cbiJdLCJuYW1lcyI6WyJudWxsVGltZSIsImVwb2NoVGltZSIsIkRhdGUiLCJub3ciLCJ1bml4VGltZSIsIk1hdGgiLCJyb3VuZCIsImlzb1RpbWUiLCJ0b0lTT1N0cmluZyIsIm1vZHVsZSIsImV4cG9ydHMiXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/pino/lib/time.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/pino/lib/tools.js":
/*!****************************************!*\
  !*** ./node_modules/pino/lib/tools.js ***!
  \****************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

eval("\n/* eslint no-prototype-builtins: 0 */ const format = __webpack_require__(/*! quick-format-unescaped */ \"(ssr)/./node_modules/quick-format-unescaped/index.js\");\nconst { mapHttpRequest, mapHttpResponse } = __webpack_require__(/*! pino-std-serializers */ \"(ssr)/./node_modules/pino-std-serializers/index.js\");\nconst SonicBoom = __webpack_require__(/*! sonic-boom */ \"(ssr)/./node_modules/sonic-boom/index.js\");\nconst onExit = __webpack_require__(/*! on-exit-leak-free */ \"(ssr)/./node_modules/on-exit-leak-free/index.js\");\nconst { lsCacheSym, chindingsSym, writeSym, serializersSym, formatOptsSym, endSym, stringifiersSym, stringifySym, stringifySafeSym, wildcardFirstSym, nestedKeySym, formattersSym, messageKeySym, errorKeySym, nestedKeyStrSym, msgPrefixSym } = __webpack_require__(/*! ./symbols */ \"(ssr)/./node_modules/pino/lib/symbols.js\");\nconst { isMainThread } = __webpack_require__(/*! worker_threads */ \"worker_threads\");\nconst transport = __webpack_require__(/*! ./transport */ \"(ssr)/./node_modules/pino/lib/transport.js\");\nfunction noop() {}\nfunction genLog(level, hook) {\n    if (!hook) return LOG;\n    return function hookWrappedLog(...args) {\n        hook.call(this, args, LOG, level);\n    };\n    function LOG(o, ...n) {\n        if (typeof o === \"object\") {\n            let msg = o;\n            if (o !== null) {\n                if (o.method && o.headers && o.socket) {\n                    o = mapHttpRequest(o);\n                } else if (typeof o.setHeader === \"function\") {\n                    o = mapHttpResponse(o);\n                }\n            }\n            let formatParams;\n            if (msg === null && n.length === 0) {\n                formatParams = [\n                    null\n                ];\n            } else {\n                msg = n.shift();\n                formatParams = n;\n            }\n            // We do not use a coercive check for `msg` as it is\n            // measurably slower than the explicit checks.\n            if (typeof this[msgPrefixSym] === \"string\" && msg !== undefined && msg !== null) {\n                msg = this[msgPrefixSym] + msg;\n            }\n            this[writeSym](o, format(msg, formatParams, this[formatOptsSym]), level);\n        } else {\n            let msg = o === undefined ? n.shift() : o;\n            // We do not use a coercive check for `msg` as it is\n            // measurably slower than the explicit checks.\n            if (typeof this[msgPrefixSym] === \"string\" && msg !== undefined && msg !== null) {\n                msg = this[msgPrefixSym] + msg;\n            }\n            this[writeSym](null, format(msg, n, this[formatOptsSym]), level);\n        }\n    }\n}\n// magically escape strings for json\n// relying on their charCodeAt\n// everything below 32 needs JSON.stringify()\n// 34 and 92 happens all the time, so we\n// have a fast case for them\nfunction asString(str) {\n    let result = \"\";\n    let last = 0;\n    let found = false;\n    let point = 255;\n    const l = str.length;\n    if (l > 100) {\n        return JSON.stringify(str);\n    }\n    for(var i = 0; i < l && point >= 32; i++){\n        point = str.charCodeAt(i);\n        if (point === 34 || point === 92) {\n            result += str.slice(last, i) + \"\\\\\";\n            last = i;\n            found = true;\n        }\n    }\n    if (!found) {\n        result = str;\n    } else {\n        result += str.slice(last);\n    }\n    return point < 32 ? JSON.stringify(str) : '\"' + result + '\"';\n}\nfunction asJson(obj, msg, num, time) {\n    const stringify = this[stringifySym];\n    const stringifySafe = this[stringifySafeSym];\n    const stringifiers = this[stringifiersSym];\n    const end = this[endSym];\n    const chindings = this[chindingsSym];\n    const serializers = this[serializersSym];\n    const formatters = this[formattersSym];\n    const messageKey = this[messageKeySym];\n    const errorKey = this[errorKeySym];\n    let data = this[lsCacheSym][num] + time;\n    // we need the child bindings added to the output first so instance logged\n    // objects can take precedence when JSON.parse-ing the resulting log line\n    data = data + chindings;\n    let value;\n    if (formatters.log) {\n        obj = formatters.log(obj);\n    }\n    const wildcardStringifier = stringifiers[wildcardFirstSym];\n    let propStr = \"\";\n    for(const key in obj){\n        value = obj[key];\n        if (Object.prototype.hasOwnProperty.call(obj, key) && value !== undefined) {\n            if (serializers[key]) {\n                value = serializers[key](value);\n            } else if (key === errorKey && serializers.err) {\n                value = serializers.err(value);\n            }\n            const stringifier = stringifiers[key] || wildcardStringifier;\n            switch(typeof value){\n                case \"undefined\":\n                case \"function\":\n                    continue;\n                case \"number\":\n                    /* eslint no-fallthrough: \"off\" */ if (Number.isFinite(value) === false) {\n                        value = null;\n                    }\n                // this case explicitly falls through to the next one\n                case \"boolean\":\n                    if (stringifier) value = stringifier(value);\n                    break;\n                case \"string\":\n                    value = (stringifier || asString)(value);\n                    break;\n                default:\n                    value = (stringifier || stringify)(value, stringifySafe);\n            }\n            if (value === undefined) continue;\n            const strKey = asString(key);\n            propStr += \",\" + strKey + \":\" + value;\n        }\n    }\n    let msgStr = \"\";\n    if (msg !== undefined) {\n        value = serializers[messageKey] ? serializers[messageKey](msg) : msg;\n        const stringifier = stringifiers[messageKey] || wildcardStringifier;\n        switch(typeof value){\n            case \"function\":\n                break;\n            case \"number\":\n                /* eslint no-fallthrough: \"off\" */ if (Number.isFinite(value) === false) {\n                    value = null;\n                }\n            // this case explicitly falls through to the next one\n            case \"boolean\":\n                if (stringifier) value = stringifier(value);\n                msgStr = ',\"' + messageKey + '\":' + value;\n                break;\n            case \"string\":\n                value = (stringifier || asString)(value);\n                msgStr = ',\"' + messageKey + '\":' + value;\n                break;\n            default:\n                value = (stringifier || stringify)(value, stringifySafe);\n                msgStr = ',\"' + messageKey + '\":' + value;\n        }\n    }\n    if (this[nestedKeySym] && propStr) {\n        // place all the obj properties under the specified key\n        // the nested key is already formatted from the constructor\n        return data + this[nestedKeyStrSym] + propStr.slice(1) + \"}\" + msgStr + end;\n    } else {\n        return data + propStr + msgStr + end;\n    }\n}\nfunction asChindings(instance, bindings) {\n    let value;\n    let data = instance[chindingsSym];\n    const stringify = instance[stringifySym];\n    const stringifySafe = instance[stringifySafeSym];\n    const stringifiers = instance[stringifiersSym];\n    const wildcardStringifier = stringifiers[wildcardFirstSym];\n    const serializers = instance[serializersSym];\n    const formatter = instance[formattersSym].bindings;\n    bindings = formatter(bindings);\n    for(const key in bindings){\n        value = bindings[key];\n        const valid = key !== \"level\" && key !== \"serializers\" && key !== \"formatters\" && key !== \"customLevels\" && bindings.hasOwnProperty(key) && value !== undefined;\n        if (valid === true) {\n            value = serializers[key] ? serializers[key](value) : value;\n            value = (stringifiers[key] || wildcardStringifier || stringify)(value, stringifySafe);\n            if (value === undefined) continue;\n            data += ',\"' + key + '\":' + value;\n        }\n    }\n    return data;\n}\nfunction hasBeenTampered(stream) {\n    return stream.write !== stream.constructor.prototype.write;\n}\nconst hasNodeCodeCoverage = process.env.NODE_V8_COVERAGE || process.env.V8_COVERAGE;\nfunction buildSafeSonicBoom(opts) {\n    const stream = new SonicBoom(opts);\n    stream.on(\"error\", filterBrokenPipe);\n    // If we are sync: false, we must flush on exit\n    // We must disable this if there is node code coverage due to\n    // https://github.com/nodejs/node/issues/49344#issuecomment-1741776308.\n    if (!hasNodeCodeCoverage && !opts.sync && isMainThread) {\n        onExit.register(stream, autoEnd);\n        stream.on(\"close\", function() {\n            onExit.unregister(stream);\n        });\n    }\n    return stream;\n    function filterBrokenPipe(err) {\n        // Impossible to replicate across all operating systems\n        /* istanbul ignore next */ if (err.code === \"EPIPE\") {\n            // If we get EPIPE, we should stop logging here\n            // however we have no control to the consumer of\n            // SonicBoom, so we just overwrite the write method\n            stream.write = noop;\n            stream.end = noop;\n            stream.flushSync = noop;\n            stream.destroy = noop;\n            return;\n        }\n        stream.removeListener(\"error\", filterBrokenPipe);\n        stream.emit(\"error\", err);\n    }\n}\nfunction autoEnd(stream, eventName) {\n    // This check is needed only on some platforms\n    /* istanbul ignore next */ if (stream.destroyed) {\n        return;\n    }\n    if (eventName === \"beforeExit\") {\n        // We still have an event loop, let's use it\n        stream.flush();\n        stream.on(\"drain\", function() {\n            stream.end();\n        });\n    } else {\n        // For some reason istanbul is not detecting this, but it's there\n        /* istanbul ignore next */ // We do not have an event loop, so flush synchronously\n        stream.flushSync();\n    }\n}\nfunction createArgsNormalizer(defaultOptions) {\n    return function normalizeArgs(instance, caller, opts = {}, stream) {\n        // support stream as a string\n        if (typeof opts === \"string\") {\n            stream = buildSafeSonicBoom({\n                dest: opts\n            });\n            opts = {};\n        } else if (typeof stream === \"string\") {\n            if (opts && opts.transport) {\n                throw Error(\"only one of option.transport or stream can be specified\");\n            }\n            stream = buildSafeSonicBoom({\n                dest: stream\n            });\n        } else if (opts instanceof SonicBoom || opts.writable || opts._writableState) {\n            stream = opts;\n            opts = {};\n        } else if (opts.transport) {\n            if (opts.transport instanceof SonicBoom || opts.transport.writable || opts.transport._writableState) {\n                throw Error(\"option.transport do not allow stream, please pass to option directly. e.g. pino(transport)\");\n            }\n            if (opts.transport.targets && opts.transport.targets.length && opts.formatters && typeof opts.formatters.level === \"function\") {\n                throw Error(\"option.transport.targets do not allow custom level formatters\");\n            }\n            let customLevels;\n            if (opts.customLevels) {\n                customLevels = opts.useOnlyCustomLevels ? opts.customLevels : Object.assign({}, opts.levels, opts.customLevels);\n            }\n            stream = transport({\n                caller,\n                ...opts.transport,\n                levels: customLevels\n            });\n        }\n        opts = Object.assign({}, defaultOptions, opts);\n        opts.serializers = Object.assign({}, defaultOptions.serializers, opts.serializers);\n        opts.formatters = Object.assign({}, defaultOptions.formatters, opts.formatters);\n        if (opts.prettyPrint) {\n            throw new Error(\"prettyPrint option is no longer supported, see the pino-pretty package (https://github.com/pinojs/pino-pretty)\");\n        }\n        const { enabled, onChild } = opts;\n        if (enabled === false) opts.level = \"silent\";\n        if (!onChild) opts.onChild = noop;\n        if (!stream) {\n            if (!hasBeenTampered(process.stdout)) {\n                // If process.stdout.fd is undefined, it means that we are running\n                // in a worker thread. Let's assume we are logging to file descriptor 1.\n                stream = buildSafeSonicBoom({\n                    fd: process.stdout.fd || 1\n                });\n            } else {\n                stream = process.stdout;\n            }\n        }\n        return {\n            opts,\n            stream\n        };\n    };\n}\nfunction stringify(obj, stringifySafeFn) {\n    try {\n        return JSON.stringify(obj);\n    } catch (_) {\n        try {\n            const stringify = stringifySafeFn || this[stringifySafeSym];\n            return stringify(obj);\n        } catch (_) {\n            return '\"[unable to serialize, circular reference is too complex to analyze]\"';\n        }\n    }\n}\nfunction buildFormatters(level, bindings, log) {\n    return {\n        level,\n        bindings,\n        log\n    };\n}\n/**\n * Convert a string integer file descriptor to a proper native integer\n * file descriptor.\n *\n * @param {string} destination The file descriptor string to attempt to convert.\n *\n * @returns {Number}\n */ function normalizeDestFileDescriptor(destination) {\n    const fd = Number(destination);\n    if (typeof destination === \"string\" && Number.isFinite(fd)) {\n        return fd;\n    }\n    // destination could be undefined if we are in a worker\n    if (destination === undefined) {\n        // This is stdout in UNIX systems\n        return 1;\n    }\n    return destination;\n}\nmodule.exports = {\n    noop,\n    buildSafeSonicBoom,\n    asChindings,\n    asJson,\n    genLog,\n    createArgsNormalizer,\n    stringify,\n    buildFormatters,\n    normalizeDestFileDescriptor\n};\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,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Z0I1RixXQUFXO1FBQzdCLGlDQUFpQztRQUNqQyxPQUFPO0lBQ1Q7SUFDQSxPQUFPNEY7QUFDVDtBQUVBQyxPQUFPQyxPQUFPLEdBQUc7SUFDZmhIO0lBQ0F3RTtJQUNBZDtJQUNBM0I7SUFDQTlCO0lBQ0F1RjtJQUNBN0Q7SUFDQWlGO0lBQ0FDO0FBQ0YiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9uZXh0LWFkbWluLWRhc2hib2FyZC8uL25vZGVfbW9kdWxlcy9waW5vL2xpYi90b29scy5qcz8zMGRhIl0sInNvdXJjZXNDb250ZW50IjpbIid1c2Ugc3RyaWN0J1xuXG4vKiBlc2xpbnQgbm8tcHJvdG90eXBlLWJ1aWx0aW5zOiAwICovXG5cbmNvbnN0IGZvcm1hdCA9IHJlcXVpcmUoJ3F1aWNrLWZvcm1hdC11bmVzY2FwZWQnKVxuY29uc3QgeyBtYXBIdHRwUmVxdWVzdCwgbWFwSHR0cFJlc3BvbnNlIH0gPSByZXF1aXJlKCdwaW5vLXN0ZC1zZXJpYWxpemVycycpXG5jb25zdCBTb25pY0Jvb20gPSByZXF1aXJlKCdzb25pYy1ib29tJylcbmNvbnN0IG9uRXhpdCA9IHJlcXVpcmUoJ29uLWV4aXQtbGVhay1mcmVlJylcbmNvbnN0IHtcbiAgbHNDYWNoZVN5bSxcbiAgY2hpbmRpbmdzU3ltLFxuICB3cml0ZVN5bSxcbiAgc2VyaWFsaXplcnNTeW0sXG4gIGZvcm1hdE9wdHNTeW0sXG4gIGVuZFN5bSxcbiAgc3RyaW5naWZpZXJzU3ltLFxuICBzdHJpbmdpZnlTeW0sXG4gIHN0cmluZ2lmeVNhZmVTeW0sXG4gIHdpbGRjYXJkRmlyc3RTeW0sXG4gIG5lc3RlZEtleVN5bSxcbiAgZm9ybWF0dGVyc1N5bSxcbiAgbWVzc2FnZUtleVN5bSxcbiAgZXJyb3JLZXlTeW0sXG4gIG5lc3RlZEtleVN0clN5bSxcbiAgbXNnUHJlZml4U3ltXG59ID0gcmVxdWlyZSgnLi9zeW1ib2xzJylcbmNvbnN0IHsgaXNNYWluVGhyZWFkIH0gPSByZXF1aXJlKCd3b3JrZXJfdGhyZWFkcycpXG5jb25zdCB0cmFuc3BvcnQgPSByZXF1aXJlKCcuL3RyYW5zcG9ydCcpXG5cbmZ1bmN0aW9uIG5vb3AgKCkge1xufVxuXG5mdW5jdGlvbiBnZW5Mb2cgKGxldmVsLCBob29rKSB7XG4gIGlmICghaG9vaykgcmV0dXJuIExPR1xuXG4gIHJldHVybiBmdW5jdGlvbiBob29rV3JhcHBlZExvZyAoLi4uYXJncykge1xuICAgIGhvb2suY2FsbCh0aGlzLCBhcmdzLCBMT0csIGxldmVsKVxuICB9XG5cbiAgZnVuY3Rpb24gTE9HIChvLCAuLi5uKSB7XG4gICAgaWYgKHR5cGVvZiBvID09PSAnb2JqZWN0Jykge1xuICAgICAgbGV0IG1zZyA9IG9cbiAgICAgIGlmIChvICE9PSBudWxsKSB7XG4gICAgICAgIGlmIChvLm1ldGhvZCAmJiBvLmhlYWRlcnMgJiYgby5zb2NrZXQpIHtcbiAgICAgICAgICBvID0gbWFwSHR0cFJlcXVlc3QobylcbiAgICAgICAgfSBlbHNlIGlmICh0eXBlb2Ygby5zZXRIZWFkZXIgPT09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgICBvID0gbWFwSHR0cFJlc3BvbnNlKG8pXG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIGxldCBmb3JtYXRQYXJhbXNcbiAgICAgIGlmIChtc2cgPT09IG51bGwgJiYgbi5sZW5ndGggPT09IDApIHtcbiAgICAgICAgZm9ybWF0UGFyYW1zID0gW251bGxdXG4gICAgICB9IGVsc2Uge1xuICAgICAgICBtc2cgPSBuLnNoaWZ0KClcbiAgICAgICAgZm9ybWF0UGFyYW1zID0gblxuICAgICAgfVxuICAgICAgLy8gV2UgZG8gbm90IHVzZSBhIGNvZXJjaXZlIGNoZWNrIGZvciBgbXNnYCBhcyBpdCBpc1xuICAgICAgLy8gbWVhc3VyYWJseSBzbG93ZXIgdGhhbiB0aGUgZXhwbGljaXQgY2hlY2tzLlxuICAgICAgaWYgKHR5cGVvZiB0aGlzW21zZ1ByZWZpeFN5bV0gPT09ICdzdHJpbmcnICYmIG1zZyAhPT0gdW5kZWZpbmVkICYmIG1zZyAhPT0gbnVsbCkge1xuICAgICAgICBtc2cgPSB0aGlzW21zZ1ByZWZpeFN5bV0gKyBtc2dcbiAgICAgIH1cbiAgICAgIHRoaXNbd3JpdGVTeW1dKG8sIGZvcm1hdChtc2csIGZvcm1hdFBhcmFtcywgdGhpc1tmb3JtYXRPcHRzU3ltXSksIGxldmVsKVxuICAgIH0gZWxzZSB7XG4gICAgICBsZXQgbXNnID0gbyA9PT0gdW5kZWZpbmVkID8gbi5zaGlmdCgpIDogb1xuXG4gICAgICAvLyBXZSBkbyBub3QgdXNlIGEgY29lcmNpdmUgY2hlY2sgZm9yIGBtc2dgIGFzIGl0IGlzXG4gICAgICAvLyBtZWFzdXJhYmx5IHNsb3dlciB0aGFuIHRoZSBleHBsaWNpdCBjaGVja3MuXG4gICAgICBpZiAodHlwZW9mIHRoaXNbbXNnUHJlZml4U3ltXSA9PT0gJ3N0cmluZycgJiYgbXNnICE9PSB1bmRlZmluZWQgJiYgbXNnICE9PSBudWxsKSB7XG4gICAgICAgIG1zZyA9IHRoaXNbbXNnUHJlZml4U3ltXSArIG1zZ1xuICAgICAgfVxuICAgICAgdGhpc1t3cml0ZVN5bV0obnVsbCwgZm9ybWF0KG1zZywgbiwgdGhpc1tmb3JtYXRPcHRzU3ltXSksIGxldmVsKVxuICAgIH1cbiAgfVxufVxuXG4vLyBtYWdpY2FsbHkgZXNjYXBlIHN0cmluZ3MgZm9yIGpzb25cbi8vIHJlbHlpbmcgb24gdGhlaXIgY2hhckNvZGVBdFxuLy8gZXZlcnl0aGluZyBiZWxvdyAzMiBuZWVkcyBKU09OLnN0cmluZ2lmeSgpXG4vLyAzNCBhbmQgOTIgaGFwcGVucyBhbGwgdGhlIHRpbWUsIHNvIHdlXG4vLyBoYXZlIGEgZmFzdCBjYXNlIGZvciB0aGVtXG5mdW5jdGlvbiBhc1N0cmluZyAoc3RyKSB7XG4gIGxldCByZXN1bHQgPSAnJ1xuICBsZXQgbGFzdCA9IDBcbiAgbGV0IGZvdW5kID0gZmFsc2VcbiAgbGV0IHBvaW50ID0gMjU1XG4gIGNvbnN0IGwgPSBzdHIubGVuZ3RoXG4gIGlmIChsID4gMTAwKSB7XG4gICAgcmV0dXJuIEpTT04uc3RyaW5naWZ5KHN0cilcbiAgfVxuICBmb3IgKHZhciBpID0gMDsgaSA8IGwgJiYgcG9pbnQgPj0gMzI7IGkrKykge1xuICAgIHBvaW50ID0gc3RyLmNoYXJDb2RlQXQoaSlcbiAgICBpZiAocG9pbnQgPT09IDM0IHx8IHBvaW50ID09PSA5Mikge1xuICAgICAgcmVzdWx0ICs9IHN0ci5zbGljZShsYXN0LCBpKSArICdcXFxcJ1xuICAgICAgbGFzdCA9IGlcbiAgICAgIGZvdW5kID0gdHJ1ZVxuICAgIH1cbiAgfVxuICBpZiAoIWZvdW5kKSB7XG4gICAgcmVzdWx0ID0gc3RyXG4gIH0gZWxzZSB7XG4gICAgcmVzdWx0ICs9IHN0ci5zbGljZShsYXN0KVxuICB9XG4gIHJldHVybiBwb2ludCA8IDMyID8gSlNPTi5zdHJpbmdpZnkoc3RyKSA6ICdcIicgKyByZXN1bHQgKyAnXCInXG59XG5cbmZ1bmN0aW9uIGFzSnNvbiAob2JqLCBtc2csIG51bSwgdGltZSkge1xuICBjb25zdCBzdHJpbmdpZnkgPSB0aGlzW3N0cmluZ2lmeVN5bV1cbiAgY29uc3Qgc3RyaW5naWZ5U2FmZSA9IHRoaXNbc3RyaW5naWZ5U2FmZVN5bV1cbiAgY29uc3Qgc3RyaW5naWZpZXJzID0gdGhpc1tzdHJpbmdpZmllcnNTeW1dXG4gIGNvbnN0IGVuZCA9IHRoaXNbZW5kU3ltXVxuICBjb25zdCBjaGluZGluZ3MgPSB0aGlzW2NoaW5kaW5nc1N5bV1cbiAgY29uc3Qgc2VyaWFsaXplcnMgPSB0aGlzW3NlcmlhbGl6ZXJzU3ltXVxuICBjb25zdCBmb3JtYXR0ZXJzID0gdGhpc1tmb3JtYXR0ZXJzU3ltXVxuICBjb25zdCBtZXNzYWdlS2V5ID0gdGhpc1ttZXNzYWdlS2V5U3ltXVxuICBjb25zdCBlcnJvcktleSA9IHRoaXNbZXJyb3JLZXlTeW1dXG4gIGxldCBkYXRhID0gdGhpc1tsc0NhY2hlU3ltXVtudW1dICsgdGltZVxuXG4gIC8vIHdlIG5lZWQgdGhlIGNoaWxkIGJpbmRpbmdzIGFkZGVkIHRvIHRoZSBvdXRwdXQgZmlyc3Qgc28gaW5zdGFuY2UgbG9nZ2VkXG4gIC8vIG9iamVjdHMgY2FuIHRha2UgcHJlY2VkZW5jZSB3aGVuIEpTT04ucGFyc2UtaW5nIHRoZSByZXN1bHRpbmcgbG9nIGxpbmVcbiAgZGF0YSA9IGRhdGEgKyBjaGluZGluZ3NcblxuICBsZXQgdmFsdWVcbiAgaWYgKGZvcm1hdHRlcnMubG9nKSB7XG4gICAgb2JqID0gZm9ybWF0dGVycy5sb2cob2JqKVxuICB9XG4gIGNvbnN0IHdpbGRjYXJkU3RyaW5naWZpZXIgPSBzdHJpbmdpZmllcnNbd2lsZGNhcmRGaXJzdFN5bV1cbiAgbGV0IHByb3BTdHIgPSAnJ1xuICBmb3IgKGNvbnN0IGtleSBpbiBvYmopIHtcbiAgICB2YWx1ZSA9IG9ialtrZXldXG4gICAgaWYgKE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbChvYmosIGtleSkgJiYgdmFsdWUgIT09IHVuZGVmaW5lZCkge1xuICAgICAgaWYgKHNlcmlhbGl6ZXJzW2tleV0pIHtcbiAgICAgICAgdmFsdWUgPSBzZXJpYWxpemVyc1trZXldKHZhbHVlKVxuICAgICAgfSBlbHNlIGlmIChrZXkgPT09IGVycm9yS2V5ICYmIHNlcmlhbGl6ZXJzLmVycikge1xuICAgICAgICB2YWx1ZSA9IHNlcmlhbGl6ZXJzLmVycih2YWx1ZSlcbiAgICAgIH1cblxuICAgICAgY29uc3Qgc3RyaW5naWZpZXIgPSBzdHJpbmdpZmllcnNba2V5XSB8fCB3aWxkY2FyZFN0cmluZ2lmaWVyXG5cbiAgICAgIHN3aXRjaCAodHlwZW9mIHZhbHVlKSB7XG4gICAgICAgIGNhc2UgJ3VuZGVmaW5lZCc6XG4gICAgICAgIGNhc2UgJ2Z1bmN0aW9uJzpcbiAgICAgICAgICBjb250aW51ZVxuICAgICAgICBjYXNlICdudW1iZXInOlxuICAgICAgICAgIC8qIGVzbGludCBuby1mYWxsdGhyb3VnaDogXCJvZmZcIiAqL1xuICAgICAgICAgIGlmIChOdW1iZXIuaXNGaW5pdGUodmFsdWUpID09PSBmYWxzZSkge1xuICAgICAgICAgICAgdmFsdWUgPSBudWxsXG4gICAgICAgICAgfVxuICAgICAgICAvLyB0aGlzIGNhc2UgZXhwbGljaXRseSBmYWxscyB0aHJvdWdoIHRvIHRoZSBuZXh0IG9uZVxuICAgICAgICBjYXNlICdib29sZWFuJzpcbiAgICAgICAgICBpZiAoc3RyaW5naWZpZXIpIHZhbHVlID0gc3RyaW5naWZpZXIodmFsdWUpXG4gICAgICAgICAgYnJlYWtcbiAgICAgICAgY2FzZSAnc3RyaW5nJzpcbiAgICAgICAgICB2YWx1ZSA9IChzdHJpbmdpZmllciB8fCBhc1N0cmluZykodmFsdWUpXG4gICAgICAgICAgYnJlYWtcbiAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICB2YWx1ZSA9IChzdHJpbmdpZmllciB8fCBzdHJpbmdpZnkpKHZhbHVlLCBzdHJpbmdpZnlTYWZlKVxuICAgICAgfVxuICAgICAgaWYgKHZhbHVlID09PSB1bmRlZmluZWQpIGNvbnRpbnVlXG4gICAgICBjb25zdCBzdHJLZXkgPSBhc1N0cmluZyhrZXkpXG4gICAgICBwcm9wU3RyICs9ICcsJyArIHN0cktleSArICc6JyArIHZhbHVlXG4gICAgfVxuICB9XG5cbiAgbGV0IG1zZ1N0ciA9ICcnXG4gIGlmIChtc2cgIT09IHVuZGVmaW5lZCkge1xuICAgIHZhbHVlID0gc2VyaWFsaXplcnNbbWVzc2FnZUtleV0gPyBzZXJpYWxpemVyc1ttZXNzYWdlS2V5XShtc2cpIDogbXNnXG4gICAgY29uc3Qgc3RyaW5naWZpZXIgPSBzdHJpbmdpZmllcnNbbWVzc2FnZUtleV0gfHwgd2lsZGNhcmRTdHJpbmdpZmllclxuXG4gICAgc3dpdGNoICh0eXBlb2YgdmFsdWUpIHtcbiAgICAgIGNhc2UgJ2Z1bmN0aW9uJzpcbiAgICAgICAgYnJlYWtcbiAgICAgIGNhc2UgJ251bWJlcic6XG4gICAgICAgIC8qIGVzbGludCBuby1mYWxsdGhyb3VnaDogXCJvZmZcIiAqL1xuICAgICAgICBpZiAoTnVtYmVyLmlzRmluaXRlKHZhbHVlKSA9PT0gZmFsc2UpIHtcbiAgICAgICAgICB2YWx1ZSA9IG51bGxcbiAgICAgICAgfVxuICAgICAgLy8gdGhpcyBjYXNlIGV4cGxpY2l0bHkgZmFsbHMgdGhyb3VnaCB0byB0aGUgbmV4dCBvbmVcbiAgICAgIGNhc2UgJ2Jvb2xlYW4nOlxuICAgICAgICBpZiAoc3RyaW5naWZpZXIpIHZhbHVlID0gc3RyaW5naWZpZXIodmFsdWUpXG4gICAgICAgIG1zZ1N0ciA9ICcsXCInICsgbWVzc2FnZUtleSArICdcIjonICsgdmFsdWVcbiAgICAgICAgYnJlYWtcbiAgICAgIGNhc2UgJ3N0cmluZyc6XG4gICAgICAgIHZhbHVlID0gKHN0cmluZ2lmaWVyIHx8IGFzU3RyaW5nKSh2YWx1ZSlcbiAgICAgICAgbXNnU3RyID0gJyxcIicgKyBtZXNzYWdlS2V5ICsgJ1wiOicgKyB2YWx1ZVxuICAgICAgICBicmVha1xuICAgICAgZGVmYXVsdDpcbiAgICAgICAgdmFsdWUgPSAoc3RyaW5naWZpZXIgfHwgc3RyaW5naWZ5KSh2YWx1ZSwgc3RyaW5naWZ5U2FmZSlcbiAgICAgICAgbXNnU3RyID0gJyxcIicgKyBtZXNzYWdlS2V5ICsgJ1wiOicgKyB2YWx1ZVxuICAgIH1cbiAgfVxuXG4gIGlmICh0aGlzW25lc3RlZEtleVN5bV0gJiYgcHJvcFN0cikge1xuICAgIC8vIHBsYWNlIGFsbCB0aGUgb2JqIHByb3BlcnRpZXMgdW5kZXIgdGhlIHNwZWNpZmllZCBrZXlcbiAgICAvLyB0aGUgbmVzdGVkIGtleSBpcyBhbHJlYWR5IGZvcm1hdHRlZCBmcm9tIHRoZSBjb25zdHJ1Y3RvclxuICAgIHJldHVybiBkYXRhICsgdGhpc1tuZXN0ZWRLZXlTdHJTeW1dICsgcHJvcFN0ci5zbGljZSgxKSArICd9JyArIG1zZ1N0ciArIGVuZFxuICB9IGVsc2Uge1xuICAgIHJldHVybiBkYXRhICsgcHJvcFN0ciArIG1zZ1N0ciArIGVuZFxuICB9XG59XG5cbmZ1bmN0aW9uIGFzQ2hpbmRpbmdzIChpbnN0YW5jZSwgYmluZGluZ3MpIHtcbiAgbGV0IHZhbHVlXG4gIGxldCBkYXRhID0gaW5zdGFuY2VbY2hpbmRpbmdzU3ltXVxuICBjb25zdCBzdHJpbmdpZnkgPSBpbnN0YW5jZVtzdHJpbmdpZnlTeW1dXG4gIGNvbnN0IHN0cmluZ2lmeVNhZmUgPSBpbnN0YW5jZVtzdHJpbmdpZnlTYWZlU3ltXVxuICBjb25zdCBzdHJpbmdpZmllcnMgPSBpbnN0YW5jZVtzdHJpbmdpZmllcnNTeW1dXG4gIGNvbnN0IHdpbGRjYXJkU3RyaW5naWZpZXIgPSBzdHJpbmdpZmllcnNbd2lsZGNhcmRGaXJzdFN5bV1cbiAgY29uc3Qgc2VyaWFsaXplcnMgPSBpbnN0YW5jZVtzZXJpYWxpemVyc1N5bV1cbiAgY29uc3QgZm9ybWF0dGVyID0gaW5zdGFuY2VbZm9ybWF0dGVyc1N5bV0uYmluZGluZ3NcbiAgYmluZGluZ3MgPSBmb3JtYXR0ZXIoYmluZGluZ3MpXG5cbiAgZm9yIChjb25zdCBrZXkgaW4gYmluZGluZ3MpIHtcbiAgICB2YWx1ZSA9IGJpbmRpbmdzW2tleV1cbiAgICBjb25zdCB2YWxpZCA9IGtleSAhPT0gJ2xldmVsJyAmJlxuICAgICAga2V5ICE9PSAnc2VyaWFsaXplcnMnICYmXG4gICAgICBrZXkgIT09ICdmb3JtYXR0ZXJzJyAmJlxuICAgICAga2V5ICE9PSAnY3VzdG9tTGV2ZWxzJyAmJlxuICAgICAgYmluZGluZ3MuaGFzT3duUHJvcGVydHkoa2V5KSAmJlxuICAgICAgdmFsdWUgIT09IHVuZGVmaW5lZFxuICAgIGlmICh2YWxpZCA9PT0gdHJ1ZSkge1xuICAgICAgdmFsdWUgPSBzZXJpYWxpemVyc1trZXldID8gc2VyaWFsaXplcnNba2V5XSh2YWx1ZSkgOiB2YWx1ZVxuICAgICAgdmFsdWUgPSAoc3RyaW5naWZpZXJzW2tleV0gfHwgd2lsZGNhcmRTdHJpbmdpZmllciB8fCBzdHJpbmdpZnkpKHZhbHVlLCBzdHJpbmdpZnlTYWZlKVxuICAgICAgaWYgKHZhbHVlID09PSB1bmRlZmluZWQpIGNvbnRpbnVlXG4gICAgICBkYXRhICs9ICcsXCInICsga2V5ICsgJ1wiOicgKyB2YWx1ZVxuICAgIH1cbiAgfVxuICByZXR1cm4gZGF0YVxufVxuXG5mdW5jdGlvbiBoYXNCZWVuVGFtcGVyZWQgKHN0cmVhbSkge1xuICByZXR1cm4gc3RyZWFtLndyaXRlICE9PSBzdHJlYW0uY29uc3RydWN0b3IucHJvdG90eXBlLndyaXRlXG59XG5cbmNvbnN0IGhhc05vZGVDb2RlQ292ZXJhZ2UgPSBwcm9jZXNzLmVudi5OT0RFX1Y4X0NPVkVSQUdFIHx8IHByb2Nlc3MuZW52LlY4X0NPVkVSQUdFXG5cbmZ1bmN0aW9uIGJ1aWxkU2FmZVNvbmljQm9vbSAob3B0cykge1xuICBjb25zdCBzdHJlYW0gPSBuZXcgU29uaWNCb29tKG9wdHMpXG4gIHN0cmVhbS5vbignZXJyb3InLCBmaWx0ZXJCcm9rZW5QaXBlKVxuICAvLyBJZiB3ZSBhcmUgc3luYzogZmFsc2UsIHdlIG11c3QgZmx1c2ggb24gZXhpdFxuICAvLyBXZSBtdXN0IGRpc2FibGUgdGhpcyBpZiB0aGVyZSBpcyBub2RlIGNvZGUgY292ZXJhZ2UgZHVlIHRvXG4gIC8vIGh0dHBzOi8vZ2l0aHViLmNvbS9ub2RlanMvbm9kZS9pc3N1ZXMvNDkzNDQjaXNzdWVjb21tZW50LTE3NDE3NzYzMDguXG4gIGlmICghaGFzTm9kZUNvZGVDb3ZlcmFnZSAmJiAhb3B0cy5zeW5jICYmIGlzTWFpblRocmVhZCkge1xuICAgIG9uRXhpdC5yZWdpc3RlcihzdHJlYW0sIGF1dG9FbmQpXG5cbiAgICBzdHJlYW0ub24oJ2Nsb3NlJywgZnVuY3Rpb24gKCkge1xuICAgICAgb25FeGl0LnVucmVnaXN0ZXIoc3RyZWFtKVxuICAgIH0pXG4gIH1cbiAgcmV0dXJuIHN0cmVhbVxuXG4gIGZ1bmN0aW9uIGZpbHRlckJyb2tlblBpcGUgKGVycikge1xuICAgIC8vIEltcG9zc2libGUgdG8gcmVwbGljYXRlIGFjcm9zcyBhbGwgb3BlcmF0aW5nIHN5c3RlbXNcbiAgICAvKiBpc3RhbmJ1bCBpZ25vcmUgbmV4dCAqL1xuICAgIGlmIChlcnIuY29kZSA9PT0gJ0VQSVBFJykge1xuICAgICAgLy8gSWYgd2UgZ2V0IEVQSVBFLCB3ZSBzaG91bGQgc3RvcCBsb2dnaW5nIGhlcmVcbiAgICAgIC8vIGhvd2V2ZXIgd2UgaGF2ZSBubyBjb250cm9sIHRvIHRoZSBjb25zdW1lciBvZlxuICAgICAgLy8gU29uaWNCb29tLCBzbyB3ZSBqdXN0IG92ZXJ3cml0ZSB0aGUgd3JpdGUgbWV0aG9kXG4gICAgICBzdHJlYW0ud3JpdGUgPSBub29wXG4gICAgICBzdHJlYW0uZW5kID0gbm9vcFxuICAgICAgc3RyZWFtLmZsdXNoU3luYyA9IG5vb3BcbiAgICAgIHN0cmVhbS5kZXN0cm95ID0gbm9vcFxuICAgICAgcmV0dXJuXG4gICAgfVxuICAgIHN0cmVhbS5yZW1vdmVMaXN0ZW5lcignZXJyb3InLCBmaWx0ZXJCcm9rZW5QaXBlKVxuICAgIHN0cmVhbS5lbWl0KCdlcnJvcicsIGVycilcbiAgfVxufVxuXG5mdW5jdGlvbiBhdXRvRW5kIChzdHJlYW0sIGV2ZW50TmFtZSkge1xuICAvLyBUaGlzIGNoZWNrIGlzIG5lZWRlZCBvbmx5IG9uIHNvbWUgcGxhdGZvcm1zXG4gIC8qIGlzdGFuYnVsIGlnbm9yZSBuZXh0ICovXG4gIGlmIChzdHJlYW0uZGVzdHJveWVkKSB7XG4gICAgcmV0dXJuXG4gIH1cblxuICBpZiAoZXZlbnROYW1lID09PSAnYmVmb3JlRXhpdCcpIHtcbiAgICAvLyBXZSBzdGlsbCBoYXZlIGFuIGV2ZW50IGxvb3AsIGxldCdzIHVzZSBpdFxuICAgIHN0cmVhbS5mbHVzaCgpXG4gICAgc3RyZWFtLm9uKCdkcmFpbicsIGZ1bmN0aW9uICgpIHtcbiAgICAgIHN0cmVhbS5lbmQoKVxuICAgIH0pXG4gIH0gZWxzZSB7XG4gICAgLy8gRm9yIHNvbWUgcmVhc29uIGlzdGFuYnVsIGlzIG5vdCBkZXRlY3RpbmcgdGhpcywgYnV0IGl0J3MgdGhlcmVcbiAgICAvKiBpc3RhbmJ1bCBpZ25vcmUgbmV4dCAqL1xuICAgIC8vIFdlIGRvIG5vdCBoYXZlIGFuIGV2ZW50IGxvb3AsIHNvIGZsdXNoIHN5bmNocm9ub3VzbHlcbiAgICBzdHJlYW0uZmx1c2hTeW5jKClcbiAgfVxufVxuXG5mdW5jdGlvbiBjcmVhdGVBcmdzTm9ybWFsaXplciAoZGVmYXVsdE9wdGlvbnMpIHtcbiAgcmV0dXJuIGZ1bmN0aW9uIG5vcm1hbGl6ZUFyZ3MgKGluc3RhbmNlLCBjYWxsZXIsIG9wdHMgPSB7fSwgc3RyZWFtKSB7XG4gICAgLy8gc3VwcG9ydCBzdHJlYW0gYXMgYSBzdHJpbmdcbiAgICBpZiAodHlwZW9mIG9wdHMgPT09ICdzdHJpbmcnKSB7XG4gICAgICBzdHJlYW0gPSBidWlsZFNhZmVTb25pY0Jvb20oeyBkZXN0OiBvcHRzIH0pXG4gICAgICBvcHRzID0ge31cbiAgICB9IGVsc2UgaWYgKHR5cGVvZiBzdHJlYW0gPT09ICdzdHJpbmcnKSB7XG4gICAgICBpZiAob3B0cyAmJiBvcHRzLnRyYW5zcG9ydCkge1xuICAgICAgICB0aHJvdyBFcnJvcignb25seSBvbmUgb2Ygb3B0aW9uLnRyYW5zcG9ydCBvciBzdHJlYW0gY2FuIGJlIHNwZWNpZmllZCcpXG4gICAgICB9XG4gICAgICBzdHJlYW0gPSBidWlsZFNhZmVTb25pY0Jvb20oeyBkZXN0OiBzdHJlYW0gfSlcbiAgICB9IGVsc2UgaWYgKG9wdHMgaW5zdGFuY2VvZiBTb25pY0Jvb20gfHwgb3B0cy53cml0YWJsZSB8fCBvcHRzLl93cml0YWJsZVN0YXRlKSB7XG4gICAgICBzdHJlYW0gPSBvcHRzXG4gICAgICBvcHRzID0ge31cbiAgICB9IGVsc2UgaWYgKG9wdHMudHJhbnNwb3J0KSB7XG4gICAgICBpZiAob3B0cy50cmFuc3BvcnQgaW5zdGFuY2VvZiBTb25pY0Jvb20gfHwgb3B0cy50cmFuc3BvcnQud3JpdGFibGUgfHwgb3B0cy50cmFuc3BvcnQuX3dyaXRhYmxlU3RhdGUpIHtcbiAgICAgICAgdGhyb3cgRXJyb3IoJ29wdGlvbi50cmFuc3BvcnQgZG8gbm90IGFsbG93IHN0cmVhbSwgcGxlYXNlIHBhc3MgdG8gb3B0aW9uIGRpcmVjdGx5LiBlLmcuIHBpbm8odHJhbnNwb3J0KScpXG4gICAgICB9XG4gICAgICBpZiAob3B0cy50cmFuc3BvcnQudGFyZ2V0cyAmJiBvcHRzLnRyYW5zcG9ydC50YXJnZXRzLmxlbmd0aCAmJiBvcHRzLmZvcm1hdHRlcnMgJiYgdHlwZW9mIG9wdHMuZm9ybWF0dGVycy5sZXZlbCA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICB0aHJvdyBFcnJvcignb3B0aW9uLnRyYW5zcG9ydC50YXJnZXRzIGRvIG5vdCBhbGxvdyBjdXN0b20gbGV2ZWwgZm9ybWF0dGVycycpXG4gICAgICB9XG5cbiAgICAgIGxldCBjdXN0b21MZXZlbHNcbiAgICAgIGlmIChvcHRzLmN1c3RvbUxldmVscykge1xuICAgICAgICBjdXN0b21MZXZlbHMgPSBvcHRzLnVzZU9ubHlDdXN0b21MZXZlbHMgPyBvcHRzLmN1c3RvbUxldmVscyA6IE9iamVjdC5hc3NpZ24oe30sIG9wdHMubGV2ZWxzLCBvcHRzLmN1c3RvbUxldmVscylcbiAgICAgIH1cbiAgICAgIHN0cmVhbSA9IHRyYW5zcG9ydCh7IGNhbGxlciwgLi4ub3B0cy50cmFuc3BvcnQsIGxldmVsczogY3VzdG9tTGV2ZWxzIH0pXG4gICAgfVxuICAgIG9wdHMgPSBPYmplY3QuYXNzaWduKHt9LCBkZWZhdWx0T3B0aW9ucywgb3B0cylcbiAgICBvcHRzLnNlcmlhbGl6ZXJzID0gT2JqZWN0LmFzc2lnbih7fSwgZGVmYXVsdE9wdGlvbnMuc2VyaWFsaXplcnMsIG9wdHMuc2VyaWFsaXplcnMpXG4gICAgb3B0cy5mb3JtYXR0ZXJzID0gT2JqZWN0LmFzc2lnbih7fSwgZGVmYXVsdE9wdGlvbnMuZm9ybWF0dGVycywgb3B0cy5mb3JtYXR0ZXJzKVxuXG4gICAgaWYgKG9wdHMucHJldHR5UHJpbnQpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcigncHJldHR5UHJpbnQgb3B0aW9uIGlzIG5vIGxvbmdlciBzdXBwb3J0ZWQsIHNlZSB0aGUgcGluby1wcmV0dHkgcGFja2FnZSAoaHR0cHM6Ly9naXRodWIuY29tL3Bpbm9qcy9waW5vLXByZXR0eSknKVxuICAgIH1cblxuICAgIGNvbnN0IHsgZW5hYmxlZCwgb25DaGlsZCB9ID0gb3B0c1xuICAgIGlmIChlbmFibGVkID09PSBmYWxzZSkgb3B0cy5sZXZlbCA9ICdzaWxlbnQnXG4gICAgaWYgKCFvbkNoaWxkKSBvcHRzLm9uQ2hpbGQgPSBub29wXG4gICAgaWYgKCFzdHJlYW0pIHtcbiAgICAgIGlmICghaGFzQmVlblRhbXBlcmVkKHByb2Nlc3Muc3Rkb3V0KSkge1xuICAgICAgICAvLyBJZiBwcm9jZXNzLnN0ZG91dC5mZCBpcyB1bmRlZmluZWQsIGl0IG1lYW5zIHRoYXQgd2UgYXJlIHJ1bm5pbmdcbiAgICAgICAgLy8gaW4gYSB3b3JrZXIgdGhyZWFkLiBMZXQncyBhc3N1bWUgd2UgYXJlIGxvZ2dpbmcgdG8gZmlsZSBkZXNjcmlwdG9yIDEuXG4gICAgICAgIHN0cmVhbSA9IGJ1aWxkU2FmZVNvbmljQm9vbSh7IGZkOiBwcm9jZXNzLnN0ZG91dC5mZCB8fCAxIH0pXG4gICAgICB9IGVsc2Uge1xuICAgICAgICBzdHJlYW0gPSBwcm9jZXNzLnN0ZG91dFxuICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4geyBvcHRzLCBzdHJlYW0gfVxuICB9XG59XG5cbmZ1bmN0aW9uIHN0cmluZ2lmeSAob2JqLCBzdHJpbmdpZnlTYWZlRm4pIHtcbiAgdHJ5IHtcbiAgICByZXR1cm4gSlNPTi5zdHJpbmdpZnkob2JqKVxuICB9IGNhdGNoIChfKSB7XG4gICAgdHJ5IHtcbiAgICAgIGNvbnN0IHN0cmluZ2lmeSA9IHN0cmluZ2lmeVNhZmVGbiB8fCB0aGlzW3N0cmluZ2lmeVNhZmVTeW1dXG4gICAgICByZXR1cm4gc3RyaW5naWZ5KG9iailcbiAgICB9IGNhdGNoIChfKSB7XG4gICAgICByZXR1cm4gJ1wiW3VuYWJsZSB0byBzZXJpYWxpemUsIGNpcmN1bGFyIHJlZmVyZW5jZSBpcyB0b28gY29tcGxleCB0byBhbmFseXplXVwiJ1xuICAgIH1cbiAgfVxufVxuXG5mdW5jdGlvbiBidWlsZEZvcm1hdHRlcnMgKGxldmVsLCBiaW5kaW5ncywgbG9nKSB7XG4gIHJldHVybiB7XG4gICAgbGV2ZWwsXG4gICAgYmluZGluZ3MsXG4gICAgbG9nXG4gIH1cbn1cblxuLyoqXG4gKiBDb252ZXJ0IGEgc3RyaW5nIGludGVnZXIgZmlsZSBkZXNjcmlwdG9yIHRvIGEgcHJvcGVyIG5hdGl2ZSBpbnRlZ2VyXG4gKiBmaWxlIGRlc2NyaXB0b3IuXG4gKlxuICogQHBhcmFtIHtzdHJpbmd9IGRlc3RpbmF0aW9uIFRoZSBmaWxlIGRlc2NyaXB0b3Igc3RyaW5nIHRvIGF0dGVtcHQgdG8gY29udmVydC5cbiAqXG4gKiBAcmV0dXJucyB7TnVtYmVyfVxuICovXG5mdW5jdGlvbiBub3JtYWxpemVEZXN0RmlsZURlc2NyaXB0b3IgKGRlc3RpbmF0aW9uKSB7XG4gIGNvbnN0IGZkID0gTnVtYmVyKGRlc3RpbmF0aW9uKVxuICBpZiAodHlwZW9mIGRlc3RpbmF0aW9uID09PSAnc3RyaW5nJyAmJiBOdW1iZXIuaXNGaW5pdGUoZmQpKSB7XG4gICAgcmV0dXJuIGZkXG4gIH1cbiAgLy8gZGVzdGluYXRpb24gY291bGQgYmUgdW5kZWZpbmVkIGlmIHdlIGFyZSBpbiBhIHdvcmtlclxuICBpZiAoZGVzdGluYXRpb24gPT09IHVuZGVmaW5lZCkge1xuICAgIC8vIFRoaXMgaXMgc3Rkb3V0IGluIFVOSVggc3lzdGVtc1xuICAgIHJldHVybiAxXG4gIH1cbiAgcmV0dXJuIGRlc3RpbmF0aW9uXG59XG5cbm1vZHVsZS5leHBvcnRzID0ge1xuICBub29wLFxuICBidWlsZFNhZmVTb25pY0Jvb20sXG4gIGFzQ2hpbmRpbmdzLFxuICBhc0pzb24sXG4gIGdlbkxvZyxcbiAgY3JlYXRlQXJnc05vcm1hbGl6ZXIsXG4gIHN0cmluZ2lmeSxcbiAgYnVpbGRGb3JtYXR0ZXJzLFxuICBub3JtYWxpemVEZXN0RmlsZURlc2NyaXB0b3Jcbn1cbiJdLCJuYW1lcyI6WyJmb3JtYXQiLCJyZXF1aXJlIiwibWFwSHR0cFJlcXVlc3QiLCJtYXBIdHRwUmVzcG9uc2UiLCJTb25pY0Jvb20iLCJvbkV4aXQiLCJsc0NhY2hlU3ltIiwiY2hpbmRpbmdzU3ltIiwid3JpdGVTeW0iLCJzZXJpYWxpemVyc1N5bSIsImZvcm1hdE9wdHNTeW0iLCJlbmRTeW0iLCJzdHJpbmdpZmllcnNTeW0iLCJzdHJpbmdpZnlTeW0iLCJzdHJpbmdpZnlTYWZlU3ltIiwid2lsZGNhcmRGaXJzdFN5bSIsIm5lc3RlZEtleVN5bSIsImZvcm1hdHRlcnNTeW0iLCJtZXNzYWdlS2V5U3ltIiwiZXJyb3JLZXlTeW0iLCJuZXN0ZWRLZXlTdHJTeW0iLCJtc2dQcmVmaXhTeW0iLCJpc01haW5UaHJlYWQiLCJ0cmFuc3BvcnQiLCJub29wIiwiZ2VuTG9nIiwibGV2ZWwiLCJob29rIiwiTE9HIiwiaG9va1dyYXBwZWRMb2ciLCJhcmdzIiwiY2FsbCIsIm8iLCJuIiwibXNnIiwibWV0aG9kIiwiaGVhZGVycyIsInNvY2tldCIsInNldEhlYWRlciIsImZvcm1hdFBhcmFtcyIsImxlbmd0aCIsInNoaWZ0IiwidW5kZWZpbmVkIiwiYXNTdHJpbmciLCJzdHIiLCJyZXN1bHQiLCJsYXN0IiwiZm91bmQiLCJwb2ludCIsImwiLCJKU09OIiwic3RyaW5naWZ5IiwiaSIsImNoYXJDb2RlQXQiLCJzbGljZSIsImFzSnNvbiIsIm9iaiIsIm51bSIsInRpbWUiLCJzdHJpbmdpZnlTYWZlIiwic3RyaW5naWZpZXJzIiwiZW5kIiwiY2hpbmRpbmdzIiwic2VyaWFsaXplcnMiLCJmb3JtYXR0ZXJzIiwibWVzc2FnZUtleSIsImVycm9yS2V5IiwiZGF0YSIsInZhbHVlIiwibG9nIiwid2lsZGNhcmRTdHJpbmdpZmllciIsInByb3BTdHIiLCJrZXkiLCJPYmplY3QiLCJwcm90b3R5cGUiLCJoYXNPd25Qcm9wZXJ0eSIsImVyciIsInN0cmluZ2lmaWVyIiwiTnVtYmVyIiwiaXNGaW5pdGUiLCJzdHJLZXkiLCJtc2dTdHIiLCJhc0NoaW5kaW5ncyIsImluc3RhbmNlIiwiYmluZGluZ3MiLCJmb3JtYXR0ZXIiLCJ2YWxpZCIsImhhc0JlZW5UYW1wZXJlZCIsInN0cmVhbSIsIndyaXRlIiwiY29uc3RydWN0b3IiLCJoYXNOb2RlQ29kZUNvdmVyYWdlIiwicHJvY2VzcyIsImVudiIsIk5PREVfVjhfQ09WRVJBR0UiLCJWOF9DT1ZFUkFHRSIsImJ1aWxkU2FmZVNvbmljQm9vbSIsIm9wdHMiLCJvbiIsImZpbHRlckJyb2tlblBpcGUiLCJzeW5jIiwicmVnaXN0ZXIiLCJhdXRvRW5kIiwidW5yZWdpc3RlciIsImNvZGUiLCJmbHVzaFN5bmMiLCJkZXN0cm95IiwicmVtb3ZlTGlzdGVuZXIiLCJlbWl0IiwiZXZlbnROYW1lIiwiZGVzdHJveWVkIiwiZmx1c2giLCJjcmVhdGVBcmdzTm9ybWFsaXplciIsImRlZmF1bHRPcHRpb25zIiwibm9ybWFsaXplQXJncyIsImNhbGxlciIsImRlc3QiLCJFcnJvciIsIndyaXRhYmxlIiwiX3dyaXRhYmxlU3RhdGUiLCJ0YXJnZXRzIiwiY3VzdG9tTGV2ZWxzIiwidXNlT25seUN1c3RvbUxldmVscyIsImFzc2lnbiIsImxldmVscyIsInByZXR0eVByaW50IiwiZW5hYmxlZCIsIm9uQ2hpbGQiLCJzdGRvdXQiLCJmZCIsInN0cmluZ2lmeVNhZmVGbiIsIl8iLCJidWlsZEZvcm1hdHRlcnMiLCJub3JtYWxpemVEZXN0RmlsZURlc2NyaXB0b3IiLCJkZXN0aW5hdGlvbiIsIm1vZHVsZSIsImV4cG9ydHMiXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/pino/lib/tools.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/pino/lib/transport.js":
/*!********************************************!*\
  !*** ./node_modules/pino/lib/transport.js ***!
  \********************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

eval("\nconst { createRequire } = __webpack_require__(/*! module */ \"module\");\nconst getCallers = __webpack_require__(/*! ./caller */ \"(ssr)/./node_modules/pino/lib/caller.js\");\nconst { join, isAbsolute, sep } = __webpack_require__(/*! node:path */ \"node:path\");\nconst sleep = __webpack_require__(/*! atomic-sleep */ \"(ssr)/./node_modules/atomic-sleep/index.js\");\nconst onExit = __webpack_require__(/*! on-exit-leak-free */ \"(ssr)/./node_modules/on-exit-leak-free/index.js\");\nconst ThreadStream = __webpack_require__(/*! thread-stream */ \"(ssr)/./node_modules/thread-stream/index.js\");\nfunction setupOnExit(stream) {\n    // This is leak free, it does not leave event handlers\n    onExit.register(stream, autoEnd);\n    onExit.registerBeforeExit(stream, flush);\n    stream.on(\"close\", function() {\n        onExit.unregister(stream);\n    });\n}\nfunction buildStream(filename, workerData, workerOpts, sync) {\n    const stream = new ThreadStream({\n        filename,\n        workerData,\n        workerOpts,\n        sync\n    });\n    stream.on(\"ready\", onReady);\n    stream.on(\"close\", function() {\n        process.removeListener(\"exit\", onExit);\n    });\n    process.on(\"exit\", onExit);\n    function onReady() {\n        process.removeListener(\"exit\", onExit);\n        stream.unref();\n        if (workerOpts.autoEnd !== false) {\n            setupOnExit(stream);\n        }\n    }\n    function onExit() {\n        /* istanbul ignore next */ if (stream.closed) {\n            return;\n        }\n        stream.flushSync();\n        // Apparently there is a very sporadic race condition\n        // that in certain OS would prevent the messages to be flushed\n        // because the thread might not have been created still.\n        // Unfortunately we need to sleep(100) in this case.\n        sleep(100);\n        stream.end();\n    }\n    return stream;\n}\nfunction autoEnd(stream) {\n    stream.ref();\n    stream.flushSync();\n    stream.end();\n    stream.once(\"close\", function() {\n        stream.unref();\n    });\n}\nfunction flush(stream) {\n    stream.flushSync();\n}\nfunction transport(fullOptions) {\n    const { pipeline, targets, levels, dedupe, worker = {}, caller = getCallers(), sync = false } = fullOptions;\n    const options = {\n        ...fullOptions.options\n    };\n    // Backwards compatibility\n    const callers = typeof caller === \"string\" ? [\n        caller\n    ] : caller;\n    // This will be eventually modified by bundlers\n    const bundlerOverrides = \"__bundlerPathsOverrides\" in globalThis ? globalThis.__bundlerPathsOverrides : {};\n    let target = fullOptions.target;\n    if (target && targets) {\n        throw new Error(\"only one of target or targets can be specified\");\n    }\n    if (targets) {\n        target = bundlerOverrides[\"pino-worker\"] || join(__dirname, \"worker.js\");\n        options.targets = targets.filter((dest)=>dest.target).map((dest)=>{\n            return {\n                ...dest,\n                target: fixTarget(dest.target)\n            };\n        });\n        options.pipelines = targets.filter((dest)=>dest.pipeline).map((dest)=>{\n            return dest.pipeline.map((t)=>{\n                return {\n                    ...t,\n                    level: dest.level,\n                    target: fixTarget(t.target)\n                };\n            });\n        });\n    } else if (pipeline) {\n        target = bundlerOverrides[\"pino-worker\"] || join(__dirname, \"worker.js\");\n        options.pipelines = [\n            pipeline.map((dest)=>{\n                return {\n                    ...dest,\n                    target: fixTarget(dest.target)\n                };\n            })\n        ];\n    }\n    if (levels) {\n        options.levels = levels;\n    }\n    if (dedupe) {\n        options.dedupe = dedupe;\n    }\n    options.pinoWillSendConfig = true;\n    return buildStream(fixTarget(target), options, worker, sync);\n    function fixTarget(origin) {\n        origin = bundlerOverrides[origin] || origin;\n        if (isAbsolute(origin) || origin.indexOf(\"file://\") === 0) {\n            return origin;\n        }\n        if (origin === \"pino/file\") {\n            return join(__dirname, \"..\", \"file.js\");\n        }\n        let fixTarget;\n        for (const filePath of callers){\n            try {\n                const context = filePath === \"node:repl\" ? process.cwd() + sep : filePath;\n                fixTarget = createRequire(context).resolve(origin);\n                break;\n            } catch (err) {\n                continue;\n            }\n        }\n        if (!fixTarget) {\n            throw new Error(`unable to determine transport target for \"${origin}\"`);\n        }\n        return fixTarget;\n    }\n}\nmodule.exports = transport;\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvcGluby9saWIvdHJhbnNwb3J0LmpzIiwibWFwcGluZ3MiOiJBQUFBO0FBRUEsTUFBTSxFQUFFQSxhQUFhLEVBQUUsR0FBR0MsbUJBQU9BLENBQUM7QUFDbEMsTUFBTUMsYUFBYUQsbUJBQU9BLENBQUM7QUFDM0IsTUFBTSxFQUFFRSxJQUFJLEVBQUVDLFVBQVUsRUFBRUMsR0FBRyxFQUFFLEdBQUdKLG1CQUFPQSxDQUFDO0FBQzFDLE1BQU1LLFFBQVFMLG1CQUFPQSxDQUFDO0FBQ3RCLE1BQU1NLFNBQVNOLG1CQUFPQSxDQUFDO0FBQ3ZCLE1BQU1PLGVBQWVQLG1CQUFPQSxDQUFDO0FBRTdCLFNBQVNRLFlBQWFDLE1BQU07SUFDMUIsc0RBQXNEO0lBQ3RESCxPQUFPSSxRQUFRLENBQUNELFFBQVFFO0lBQ3hCTCxPQUFPTSxrQkFBa0IsQ0FBQ0gsUUFBUUk7SUFFbENKLE9BQU9LLEVBQUUsQ0FBQyxTQUFTO1FBQ2pCUixPQUFPUyxVQUFVLENBQUNOO0lBQ3BCO0FBQ0Y7QUFFQSxTQUFTTyxZQUFhQyxRQUFRLEVBQUVDLFVBQVUsRUFBRUMsVUFBVSxFQUFFQyxJQUFJO0lBQzFELE1BQU1YLFNBQVMsSUFBSUYsYUFBYTtRQUM5QlU7UUFDQUM7UUFDQUM7UUFDQUM7SUFDRjtJQUVBWCxPQUFPSyxFQUFFLENBQUMsU0FBU087SUFDbkJaLE9BQU9LLEVBQUUsQ0FBQyxTQUFTO1FBQ2pCUSxRQUFRQyxjQUFjLENBQUMsUUFBUWpCO0lBQ2pDO0lBRUFnQixRQUFRUixFQUFFLENBQUMsUUFBUVI7SUFFbkIsU0FBU2U7UUFDUEMsUUFBUUMsY0FBYyxDQUFDLFFBQVFqQjtRQUMvQkcsT0FBT2UsS0FBSztRQUVaLElBQUlMLFdBQVdSLE9BQU8sS0FBSyxPQUFPO1lBQ2hDSCxZQUFZQztRQUNkO0lBQ0Y7SUFFQSxTQUFTSDtRQUNQLHdCQUF3QixHQUN4QixJQUFJRyxPQUFPZ0IsTUFBTSxFQUFFO1lBQ2pCO1FBQ0Y7UUFDQWhCLE9BQU9pQixT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Q2hCb0Q7Z0JBRUpQLFlBQVlsRCxjQUFjMEQsU0FBU0UsT0FBTyxDQUFDTDtnQkFDM0M7WUFDRixFQUFFLE9BQU9NLEtBQUs7Z0JBRVo7WUFDRjtRQUNGO1FBRUEsSUFBSSxDQUFDWCxXQUFXO1lBQ2QsTUFBTSxJQUFJTCxNQUFNLENBQUMsMENBQTBDLEVBQUVVLE9BQU8sQ0FBQyxDQUFDO1FBQ3hFO1FBRUEsT0FBT0w7SUFDVDtBQUNGO0FBRUFZLE9BQU9DLE9BQU8sR0FBR2hDIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vbmV4dC1hZG1pbi1kYXNoYm9hcmQvLi9ub2RlX21vZHVsZXMvcGluby9saWIvdHJhbnNwb3J0LmpzPzU2MTIiXSwic291cmNlc0NvbnRlbnQiOlsiJ3VzZSBzdHJpY3QnXG5cbmNvbnN0IHsgY3JlYXRlUmVxdWlyZSB9ID0gcmVxdWlyZSgnbW9kdWxlJylcbmNvbnN0IGdldENhbGxlcnMgPSByZXF1aXJlKCcuL2NhbGxlcicpXG5jb25zdCB7IGpvaW4sIGlzQWJzb2x1dGUsIHNlcCB9ID0gcmVxdWlyZSgnbm9kZTpwYXRoJylcbmNvbnN0IHNsZWVwID0gcmVxdWlyZSgnYXRvbWljLXNsZWVwJylcbmNvbnN0IG9uRXhpdCA9IHJlcXVpcmUoJ29uLWV4aXQtbGVhay1mcmVlJylcbmNvbnN0IFRocmVhZFN0cmVhbSA9IHJlcXVpcmUoJ3RocmVhZC1zdHJlYW0nKVxuXG5mdW5jdGlvbiBzZXR1cE9uRXhpdCAoc3RyZWFtKSB7XG4gIC8vIFRoaXMgaXMgbGVhayBmcmVlLCBpdCBkb2VzIG5vdCBsZWF2ZSBldmVudCBoYW5kbGVyc1xuICBvbkV4aXQucmVnaXN0ZXIoc3RyZWFtLCBhdXRvRW5kKVxuICBvbkV4aXQucmVnaXN0ZXJCZWZvcmVFeGl0KHN0cmVhbSwgZmx1c2gpXG5cbiAgc3RyZWFtLm9uKCdjbG9zZScsIGZ1bmN0aW9uICgpIHtcbiAgICBvbkV4aXQudW5yZWdpc3RlcihzdHJlYW0pXG4gIH0pXG59XG5cbmZ1bmN0aW9uIGJ1aWxkU3RyZWFtIChmaWxlbmFtZSwgd29ya2VyRGF0YSwgd29ya2VyT3B0cywgc3luYykge1xuICBjb25zdCBzdHJlYW0gPSBuZXcgVGhyZWFkU3RyZWFtKHtcbiAgICBmaWxlbmFtZSxcbiAgICB3b3JrZXJEYXRhLFxuICAgIHdvcmtlck9wdHMsXG4gICAgc3luY1xuICB9KVxuXG4gIHN0cmVhbS5vbigncmVhZHknLCBvblJlYWR5KVxuICBzdHJlYW0ub24oJ2Nsb3NlJywgZnVuY3Rpb24gKCkge1xuICAgIHByb2Nlc3MucmVtb3ZlTGlzdGVuZXIoJ2V4aXQnLCBvbkV4aXQpXG4gIH0pXG5cbiAgcHJvY2Vzcy5vbignZXhpdCcsIG9uRXhpdClcblxuICBmdW5jdGlvbiBvblJlYWR5ICgpIHtcbiAgICBwcm9jZXNzLnJlbW92ZUxpc3RlbmVyKCdleGl0Jywgb25FeGl0KVxuICAgIHN0cmVhbS51bnJlZigpXG5cbiAgICBpZiAod29ya2VyT3B0cy5hdXRvRW5kICE9PSBmYWxzZSkge1xuICAgICAgc2V0dXBPbkV4aXQoc3RyZWFtKVxuICAgIH1cbiAgfVxuXG4gIGZ1bmN0aW9uIG9uRXhpdCAoKSB7XG4gICAgLyogaXN0YW5idWwgaWdub3JlIG5leHQgKi9cbiAgICBpZiAoc3RyZWFtLmNsb3NlZCkge1xuICAgICAgcmV0dXJuXG4gICAgfVxuICAgIHN0cmVhbS5mbHVzaFN5bmMoKVxuICAgIC8vIEFwcGFyZW50bHkgdGhlcmUgaXMgYSB2ZXJ5IHNwb3JhZGljIHJhY2UgY29uZGl0aW9uXG4gICAgLy8gdGhhdCBpbiBjZXJ0YWluIE9TIHdvdWxkIHByZXZlbnQgdGhlIG1lc3NhZ2VzIHRvIGJlIGZsdXNoZWRcbiAgICAvLyBiZWNhdXNlIHRoZSB0aHJlYWQgbWlnaHQgbm90IGhhdmUgYmVlbiBjcmVhdGVkIHN0aWxsLlxuICAgIC8vIFVuZm9ydHVuYXRlbHkgd2UgbmVlZCB0byBzbGVlcCgxMDApIGluIHRoaXMgY2FzZS5cbiAgICBzbGVlcCgxMDApXG4gICAgc3RyZWFtLmVuZCgpXG4gIH1cblxuICByZXR1cm4gc3RyZWFtXG59XG5cbmZ1bmN0aW9uIGF1dG9FbmQgKHN0cmVhbSkge1xuICBzdHJlYW0ucmVmKClcbiAgc3RyZWFtLmZsdXNoU3luYygpXG4gIHN0cmVhbS5lbmQoKVxuICBzdHJlYW0ub25jZSgnY2xvc2UnLCBmdW5jdGlvbiAoKSB7XG4gICAgc3RyZWFtLnVucmVmKClcbiAgfSlcbn1cblxuZnVuY3Rpb24gZmx1c2ggKHN0cmVhbSkge1xuICBzdHJlYW0uZmx1c2hTeW5jKClcbn1cblxuZnVuY3Rpb24gdHJhbnNwb3J0IChmdWxsT3B0aW9ucykge1xuICBjb25zdCB7IHBpcGVsaW5lLCB0YXJnZXRzLCBsZXZlbHMsIGRlZHVwZSwgd29ya2VyID0ge30sIGNhbGxlciA9IGdldENhbGxlcnMoKSwgc3luYyA9IGZhbHNlIH0gPSBmdWxsT3B0aW9uc1xuXG4gIGNvbnN0IG9wdGlvbnMgPSB7XG4gICAgLi4uZnVsbE9wdGlvbnMub3B0aW9uc1xuICB9XG5cbiAgLy8gQmFja3dhcmRzIGNvbXBhdGliaWxpdHlcbiAgY29uc3QgY2FsbGVycyA9IHR5cGVvZiBjYWxsZXIgPT09ICdzdHJpbmcnID8gW2NhbGxlcl0gOiBjYWxsZXJcblxuICAvLyBUaGlzIHdpbGwgYmUgZXZlbnR1YWxseSBtb2RpZmllZCBieSBidW5kbGVyc1xuICBjb25zdCBidW5kbGVyT3ZlcnJpZGVzID0gJ19fYnVuZGxlclBhdGhzT3ZlcnJpZGVzJyBpbiBnbG9iYWxUaGlzID8gZ2xvYmFsVGhpcy5fX2J1bmRsZXJQYXRoc092ZXJyaWRlcyA6IHt9XG5cbiAgbGV0IHRhcmdldCA9IGZ1bGxPcHRpb25zLnRhcmdldFxuXG4gIGlmICh0YXJnZXQgJiYgdGFyZ2V0cykge1xuICAgIHRocm93IG5ldyBFcnJvcignb25seSBvbmUgb2YgdGFyZ2V0IG9yIHRhcmdldHMgY2FuIGJlIHNwZWNpZmllZCcpXG4gIH1cblxuICBpZiAodGFyZ2V0cykge1xuICAgIHRhcmdldCA9IGJ1bmRsZXJPdmVycmlkZXNbJ3Bpbm8td29ya2VyJ10gfHwgam9pbihfX2Rpcm5hbWUsICd3b3JrZXIuanMnKVxuICAgIG9wdGlvbnMudGFyZ2V0cyA9IHRhcmdldHMuZmlsdGVyKGRlc3QgPT4gZGVzdC50YXJnZXQpLm1hcCgoZGVzdCkgPT4ge1xuICAgICAgcmV0dXJuIHtcbiAgICAgICAgLi4uZGVzdCxcbiAgICAgICAgdGFyZ2V0OiBmaXhUYXJnZXQoZGVzdC50YXJnZXQpXG4gICAgICB9XG4gICAgfSlcbiAgICBvcHRpb25zLnBpcGVsaW5lcyA9IHRhcmdldHMuZmlsdGVyKGRlc3QgPT4gZGVzdC5waXBlbGluZSkubWFwKChkZXN0KSA9PiB7XG4gICAgICByZXR1cm4gZGVzdC5waXBlbGluZS5tYXAoKHQpID0+IHtcbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAuLi50LFxuICAgICAgICAgIGxldmVsOiBkZXN0LmxldmVsLCAvLyBkdXBsaWNhdGUgdGhlIHBpcGVsaW5lIGBsZXZlbGAgcHJvcGVydHkgZGVmaW5lZCBpbiB0aGUgdXBwZXIgbGV2ZWxcbiAgICAgICAgICB0YXJnZXQ6IGZpeFRhcmdldCh0LnRhcmdldClcbiAgICAgICAgfVxuICAgICAgfSlcbiAgICB9KVxuICB9IGVsc2UgaWYgKHBpcGVsaW5lKSB7XG4gICAgdGFyZ2V0ID0gYnVuZGxlck92ZXJyaWRlc1sncGluby13b3JrZXInXSB8fCBqb2luKF9fZGlybmFtZSwgJ3dvcmtlci5qcycpXG4gICAgb3B0aW9ucy5waXBlbGluZXMgPSBbcGlwZWxpbmUubWFwKChkZXN0KSA9PiB7XG4gICAgICByZXR1cm4ge1xuICAgICAgICAuLi5kZXN0LFxuICAgICAgICB0YXJnZXQ6IGZpeFRhcmdldChkZXN0LnRhcmdldClcbiAgICAgIH1cbiAgICB9KV1cbiAgfVxuXG4gIGlmIChsZXZlbHMpIHtcbiAgICBvcHRpb25zLmxldmVscyA9IGxldmVsc1xuICB9XG5cbiAgaWYgKGRlZHVwZSkge1xuICAgIG9wdGlvbnMuZGVkdXBlID0gZGVkdXBlXG4gIH1cblxuICBvcHRpb25zLnBpbm9XaWxsU2VuZENvbmZpZyA9IHRydWVcblxuICByZXR1cm4gYnVpbGRTdHJlYW0oZml4VGFyZ2V0KHRhcmdldCksIG9wdGlvbnMsIHdvcmtlciwgc3luYylcblxuICBmdW5jdGlvbiBmaXhUYXJnZXQgKG9yaWdpbikge1xuICAgIG9yaWdpbiA9IGJ1bmRsZXJPdmVycmlkZXNbb3JpZ2luXSB8fCBvcmlnaW5cblxuICAgIGlmIChpc0Fic29sdXRlKG9yaWdpbikgfHwgb3JpZ2luLmluZGV4T2YoJ2ZpbGU6Ly8nKSA9PT0gMCkge1xuICAgICAgcmV0dXJuIG9yaWdpblxuICAgIH1cblxuICAgIGlmIChvcmlnaW4gPT09ICdwaW5vL2ZpbGUnKSB7XG4gICAgICByZXR1cm4gam9pbihfX2Rpcm5hbWUsICcuLicsICdmaWxlLmpzJylcbiAgICB9XG5cbiAgICBsZXQgZml4VGFyZ2V0XG5cbiAgICBmb3IgKGNvbnN0IGZpbGVQYXRoIG9mIGNhbGxlcnMpIHtcbiAgICAgIHRyeSB7XG4gICAgICAgIGNvbnN0IGNvbnRleHQgPSBmaWxlUGF0aCA9PT0gJ25vZGU6cmVwbCdcbiAgICAgICAgICA/IHByb2Nlc3MuY3dkKCkgKyBzZXBcbiAgICAgICAgICA6IGZpbGVQYXRoXG5cbiAgICAgICAgZml4VGFyZ2V0ID0gY3JlYXRlUmVxdWlyZShjb250ZXh0KS5yZXNvbHZlKG9yaWdpbilcbiAgICAgICAgYnJlYWtcbiAgICAgIH0gY2F0Y2ggKGVycikge1xuICAgICAgICAvLyBTaWxlbnQgY2F0Y2hcbiAgICAgICAgY29udGludWVcbiAgICAgIH1cbiAgICB9XG5cbiAgICBpZiAoIWZpeFRhcmdldCkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKGB1bmFibGUgdG8gZGV0ZXJtaW5lIHRyYW5zcG9ydCB0YXJnZXQgZm9yIFwiJHtvcmlnaW59XCJgKVxuICAgIH1cblxuICAgIHJldHVybiBmaXhUYXJnZXRcbiAgfVxufVxuXG5tb2R1bGUuZXhwb3J0cyA9IHRyYW5zcG9ydFxuIl0sIm5hbWVzIjpbImNyZWF0ZVJlcXVpcmUiLCJyZXF1aXJlIiwiZ2V0Q2FsbGVycyIsImpvaW4iLCJpc0Fic29sdXRlIiwic2VwIiwic2xlZXAiLCJvbkV4aXQiLCJUaHJlYWRTdHJlYW0iLCJzZXR1cE9uRXhpdCIsInN0cmVhbSIsInJlZ2lzdGVyIiwiYXV0b0VuZCIsInJlZ2lzdGVyQmVmb3JlRXhpdCIsImZsdXNoIiwib24iLCJ1bnJlZ2lzdGVyIiwiYnVpbGRTdHJlYW0iLCJmaWxlbmFtZSIsIndvcmtlckRhdGEiLCJ3b3JrZXJPcHRzIiwic3luYyIsIm9uUmVhZHkiLCJwcm9jZXNzIiwicmVtb3ZlTGlzdGVuZXIiLCJ1bnJlZiIsImNsb3NlZCIsImZsdXNoU3luYyIsImVuZCIsInJlZiIsIm9uY2UiLCJ0cmFuc3BvcnQiLCJmdWxsT3B0aW9ucyIsInBpcGVsaW5lIiwidGFyZ2V0cyIsImxldmVscyIsImRlZHVwZSIsIndvcmtlciIsImNhbGxlciIsIm9wdGlvbnMiLCJjYWxsZXJzIiwiYnVuZGxlck92ZXJyaWRlcyIsImdsb2JhbFRoaXMiLCJfX2J1bmRsZXJQYXRoc092ZXJyaWRlcyIsInRhcmdldCIsIkVycm9yIiwiX19kaXJuYW1lIiwiZmlsdGVyIiwiZGVzdCIsIm1hcCIsImZpeFRhcmdldCIsInBpcGVsaW5lcyIsInQiLCJsZXZlbCIsInBpbm9XaWxsU2VuZENvbmZpZyIsIm9yaWdpbiIsImluZGV4T2YiLCJmaWxlUGF0aCIsImNvbnRleHQiLCJjd2QiLCJyZXNvbHZlIiwiZXJyIiwibW9kdWxlIiwiZXhwb3J0cyJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/pino/lib/transport.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/pino/pino.js":
/*!***********************************!*\
  !*** ./node_modules/pino/pino.js ***!
  \***********************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

eval("\nconst os = __webpack_require__(/*! node:os */ \"node:os\");\nconst stdSerializers = __webpack_require__(/*! pino-std-serializers */ \"(ssr)/./node_modules/pino-std-serializers/index.js\");\nconst caller = __webpack_require__(/*! ./lib/caller */ \"(ssr)/./node_modules/pino/lib/caller.js\");\nconst redaction = __webpack_require__(/*! ./lib/redaction */ \"(ssr)/./node_modules/pino/lib/redaction.js\");\nconst time = __webpack_require__(/*! ./lib/time */ \"(ssr)/./node_modules/pino/lib/time.js\");\nconst proto = __webpack_require__(/*! ./lib/proto */ \"(ssr)/./node_modules/pino/lib/proto.js\");\nconst symbols = __webpack_require__(/*! ./lib/symbols */ \"(ssr)/./node_modules/pino/lib/symbols.js\");\nconst { configure } = __webpack_require__(/*! safe-stable-stringify */ \"(ssr)/./node_modules/safe-stable-stringify/index.js\");\nconst { assertDefaultLevelFound, mappings, genLsCache, genLevelComparison, assertLevelComparison } = __webpack_require__(/*! ./lib/levels */ \"(ssr)/./node_modules/pino/lib/levels.js\");\nconst { DEFAULT_LEVELS, SORTING_ORDER } = __webpack_require__(/*! ./lib/constants */ \"(ssr)/./node_modules/pino/lib/constants.js\");\nconst { createArgsNormalizer, asChindings, buildSafeSonicBoom, buildFormatters, stringify, normalizeDestFileDescriptor, noop } = __webpack_require__(/*! ./lib/tools */ \"(ssr)/./node_modules/pino/lib/tools.js\");\nconst { version } = __webpack_require__(/*! ./lib/meta */ \"(ssr)/./node_modules/pino/lib/meta.js\");\nconst { chindingsSym, redactFmtSym, serializersSym, timeSym, timeSliceIndexSym, streamSym, stringifySym, stringifySafeSym, stringifiersSym, setLevelSym, endSym, formatOptsSym, messageKeySym, errorKeySym, nestedKeySym, mixinSym, levelCompSym, useOnlyCustomLevelsSym, formattersSym, hooksSym, nestedKeyStrSym, mixinMergeStrategySym, msgPrefixSym } = symbols;\nconst { epochTime, nullTime } = time;\nconst { pid } = process;\nconst hostname = os.hostname();\nconst defaultErrorSerializer = stdSerializers.err;\nconst defaultOptions = {\n    level: \"info\",\n    levelComparison: SORTING_ORDER.ASC,\n    levels: DEFAULT_LEVELS,\n    messageKey: \"msg\",\n    errorKey: \"err\",\n    nestedKey: null,\n    enabled: true,\n    base: {\n        pid,\n        hostname\n    },\n    serializers: Object.assign(Object.create(null), {\n        err: defaultErrorSerializer\n    }),\n    formatters: Object.assign(Object.create(null), {\n        bindings (bindings) {\n            return bindings;\n        },\n        level (label, number) {\n            return {\n                level: number\n            };\n        }\n    }),\n    hooks: {\n        logMethod: undefined,\n        streamWrite: undefined\n    },\n    timestamp: epochTime,\n    name: undefined,\n    redact: null,\n    customLevels: null,\n    useOnlyCustomLevels: false,\n    depthLimit: 5,\n    edgeLimit: 100\n};\nconst normalize = createArgsNormalizer(defaultOptions);\nconst serializers = Object.assign(Object.create(null), stdSerializers);\nfunction pino(...args) {\n    const instance = {};\n    const { opts, stream } = normalize(instance, caller(), ...args);\n    if (opts.level && typeof opts.level === \"string\" && DEFAULT_LEVELS[opts.level.toLowerCase()] !== undefined) opts.level = opts.level.toLowerCase();\n    const { redact, crlf, serializers, timestamp, messageKey, errorKey, nestedKey, base, name, level, customLevels, levelComparison, mixin, mixinMergeStrategy, useOnlyCustomLevels, formatters, hooks, depthLimit, edgeLimit, onChild, msgPrefix } = opts;\n    const stringifySafe = configure({\n        maximumDepth: depthLimit,\n        maximumBreadth: edgeLimit\n    });\n    const allFormatters = buildFormatters(formatters.level, formatters.bindings, formatters.log);\n    const stringifyFn = stringify.bind({\n        [stringifySafeSym]: stringifySafe\n    });\n    const stringifiers = redact ? redaction(redact, stringifyFn) : {};\n    const formatOpts = redact ? {\n        stringify: stringifiers[redactFmtSym]\n    } : {\n        stringify: stringifyFn\n    };\n    const end = \"}\" + (crlf ? \"\\r\\n\" : \"\\n\");\n    const coreChindings = asChindings.bind(null, {\n        [chindingsSym]: \"\",\n        [serializersSym]: serializers,\n        [stringifiersSym]: stringifiers,\n        [stringifySym]: stringify,\n        [stringifySafeSym]: stringifySafe,\n        [formattersSym]: allFormatters\n    });\n    let chindings = \"\";\n    if (base !== null) {\n        if (name === undefined) {\n            chindings = coreChindings(base);\n        } else {\n            chindings = coreChindings(Object.assign({}, base, {\n                name\n            }));\n        }\n    }\n    const time = timestamp instanceof Function ? timestamp : timestamp ? epochTime : nullTime;\n    const timeSliceIndex = time().indexOf(\":\") + 1;\n    if (useOnlyCustomLevels && !customLevels) throw Error(\"customLevels is required if useOnlyCustomLevels is set true\");\n    if (mixin && typeof mixin !== \"function\") throw Error(`Unknown mixin type \"${typeof mixin}\" - expected \"function\"`);\n    if (msgPrefix && typeof msgPrefix !== \"string\") throw Error(`Unknown msgPrefix type \"${typeof msgPrefix}\" - expected \"string\"`);\n    assertDefaultLevelFound(level, customLevels, useOnlyCustomLevels);\n    const levels = mappings(customLevels, useOnlyCustomLevels);\n    if (typeof stream.emit === \"function\") {\n        stream.emit(\"message\", {\n            code: \"PINO_CONFIG\",\n            config: {\n                levels,\n                messageKey,\n                errorKey\n            }\n        });\n    }\n    assertLevelComparison(levelComparison);\n    const levelCompFunc = genLevelComparison(levelComparison);\n    Object.assign(instance, {\n        levels,\n        [levelCompSym]: levelCompFunc,\n        [useOnlyCustomLevelsSym]: useOnlyCustomLevels,\n        [streamSym]: stream,\n        [timeSym]: time,\n        [timeSliceIndexSym]: timeSliceIndex,\n        [stringifySym]: stringify,\n        [stringifySafeSym]: stringifySafe,\n        [stringifiersSym]: stringifiers,\n        [endSym]: end,\n        [formatOptsSym]: formatOpts,\n        [messageKeySym]: messageKey,\n        [errorKeySym]: errorKey,\n        [nestedKeySym]: nestedKey,\n        // protect against injection\n        [nestedKeyStrSym]: nestedKey ? `,${JSON.stringify(nestedKey)}:{` : \"\",\n        [serializersSym]: serializers,\n        [mixinSym]: mixin,\n        [mixinMergeStrategySym]: mixinMergeStrategy,\n        [chindingsSym]: chindings,\n        [formattersSym]: allFormatters,\n        [hooksSym]: hooks,\n        silent: noop,\n        onChild,\n        [msgPrefixSym]: msgPrefix\n    });\n    Object.setPrototypeOf(instance, proto());\n    genLsCache(instance);\n    instance[setLevelSym](level);\n    return instance;\n}\nmodule.exports = pino;\nmodule.exports.destination = (dest = process.stdout.fd)=>{\n    if (typeof dest === \"object\") {\n        dest.dest = normalizeDestFileDescriptor(dest.dest || process.stdout.fd);\n        return buildSafeSonicBoom(dest);\n    } else {\n        return buildSafeSonicBoom({\n            dest: normalizeDestFileDescriptor(dest),\n            minLength: 0\n        });\n    }\n};\nmodule.exports.transport = __webpack_require__(/*! ./lib/transport */ \"(ssr)/./node_modules/pino/lib/transport.js\");\nmodule.exports.multistream = __webpack_require__(/*! ./lib/multistream */ \"(ssr)/./node_modules/pino/lib/multistream.js\");\nmodule.exports.levels = mappings();\nmodule.exports.stdSerializers = serializers;\nmodule.exports.stdTimeFunctions = Object.assign({}, time);\nmodule.exports.symbols = symbols;\nmodule.exports.version = version;\n// Enables default and name export with TypeScript and Babel\nmodule.exports[\"default\"] = pino;\nmodule.exports.pino = pino;\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,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QUFFdUcsTUFBTXBHLDRCQUE0Qm9HO1lBQU9HLFdBQVc7UUFBRTtJQUNwRjtBQUNGO0FBRUFOLG1IQUFtQztBQUNuQ0EseUhBQXFDO0FBRXJDQSxxQkFBcUIsR0FBRzVHO0FBQ3hCNEcsNkJBQTZCLEdBQUd0RDtBQUNoQ3NELCtCQUErQixHQUFHckQsT0FBT0MsTUFBTSxDQUFDLENBQUMsR0FBRzdEO0FBQ3BEaUgsc0JBQXNCLEdBQUcvRztBQUN6QitHLHNCQUFzQixHQUFHL0Y7QUFFekIsNERBQTREO0FBQzVEK0YseUJBQXNCLEdBQUdsQztBQUN6QmtDLG1CQUFtQixHQUFHbEMiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9uZXh0LWFkbWluLWRhc2hib2FyZC8uL25vZGVfbW9kdWxlcy9waW5vL3Bpbm8uanM/Mjg5YSJdLCJzb3VyY2VzQ29udGVudCI6WyIndXNlIHN0cmljdCdcblxuY29uc3Qgb3MgPSByZXF1aXJlKCdub2RlOm9zJylcbmNvbnN0IHN0ZFNlcmlhbGl6ZXJzID0gcmVxdWlyZSgncGluby1zdGQtc2VyaWFsaXplcnMnKVxuY29uc3QgY2FsbGVyID0gcmVxdWlyZSgnLi9saWIvY2FsbGVyJylcbmNvbnN0IHJlZGFjdGlvbiA9IHJlcXVpcmUoJy4vbGliL3JlZGFjdGlvbicpXG5jb25zdCB0aW1lID0gcmVxdWlyZSgnLi9saWIvdGltZScpXG5jb25zdCBwcm90byA9IHJlcXVpcmUoJy4vbGliL3Byb3RvJylcbmNvbnN0IHN5bWJvbHMgPSByZXF1aXJlKCcuL2xpYi9zeW1ib2xzJylcbmNvbnN0IHsgY29uZmlndXJlIH0gPSByZXF1aXJlKCdzYWZlLXN0YWJsZS1zdHJpbmdpZnknKVxuY29uc3QgeyBhc3NlcnREZWZhdWx0TGV2ZWxGb3VuZCwgbWFwcGluZ3MsIGdlbkxzQ2FjaGUsIGdlbkxldmVsQ29tcGFyaXNvbiwgYXNzZXJ0TGV2ZWxDb21wYXJpc29uIH0gPSByZXF1aXJlKCcuL2xpYi9sZXZlbHMnKVxuY29uc3QgeyBERUZBVUxUX0xFVkVMUywgU09SVElOR19PUkRFUiB9ID0gcmVxdWlyZSgnLi9saWIvY29uc3RhbnRzJylcbmNvbnN0IHtcbiAgY3JlYXRlQXJnc05vcm1hbGl6ZXIsXG4gIGFzQ2hpbmRpbmdzLFxuICBidWlsZFNhZmVTb25pY0Jvb20sXG4gIGJ1aWxkRm9ybWF0dGVycyxcbiAgc3RyaW5naWZ5LFxuICBub3JtYWxpemVEZXN0RmlsZURlc2NyaXB0b3IsXG4gIG5vb3Bcbn0gPSByZXF1aXJlKCcuL2xpYi90b29scycpXG5jb25zdCB7IHZlcnNpb24gfSA9IHJlcXVpcmUoJy4vbGliL21ldGEnKVxuY29uc3Qge1xuICBjaGluZGluZ3NTeW0sXG4gIHJlZGFjdEZtdFN5bSxcbiAgc2VyaWFsaXplcnNTeW0sXG4gIHRpbWVTeW0sXG4gIHRpbWVTbGljZUluZGV4U3ltLFxuICBzdHJlYW1TeW0sXG4gIHN0cmluZ2lmeVN5bSxcbiAgc3RyaW5naWZ5U2FmZVN5bSxcbiAgc3RyaW5naWZpZXJzU3ltLFxuICBzZXRMZXZlbFN5bSxcbiAgZW5kU3ltLFxuICBmb3JtYXRPcHRzU3ltLFxuICBtZXNzYWdlS2V5U3ltLFxuICBlcnJvcktleVN5bSxcbiAgbmVzdGVkS2V5U3ltLFxuICBtaXhpblN5bSxcbiAgbGV2ZWxDb21wU3ltLFxuICB1c2VPbmx5Q3VzdG9tTGV2ZWxzU3ltLFxuICBmb3JtYXR0ZXJzU3ltLFxuICBob29rc1N5bSxcbiAgbmVzdGVkS2V5U3RyU3ltLFxuICBtaXhpbk1lcmdlU3RyYXRlZ3lTeW0sXG4gIG1zZ1ByZWZpeFN5bVxufSA9IHN5bWJvbHNcbmNvbnN0IHsgZXBvY2hUaW1lLCBudWxsVGltZSB9ID0gdGltZVxuY29uc3QgeyBwaWQgfSA9IHByb2Nlc3NcbmNvbnN0IGhvc3RuYW1lID0gb3MuaG9zdG5hbWUoKVxuY29uc3QgZGVmYXVsdEVycm9yU2VyaWFsaXplciA9IHN0ZFNlcmlhbGl6ZXJzLmVyclxuY29uc3QgZGVmYXVsdE9wdGlvbnMgPSB7XG4gIGxldmVsOiAnaW5mbycsXG4gIGxldmVsQ29tcGFyaXNvbjogU09SVElOR19PUkRFUi5BU0MsXG4gIGxldmVsczogREVGQVVMVF9MRVZFTFMsXG4gIG1lc3NhZ2VLZXk6ICdtc2cnLFxuICBlcnJvcktleTogJ2VycicsXG4gIG5lc3RlZEtleTogbnVsbCxcbiAgZW5hYmxlZDogdHJ1ZSxcbiAgYmFzZTogeyBwaWQsIGhvc3RuYW1lIH0sXG4gIHNlcmlhbGl6ZXJzOiBPYmplY3QuYXNzaWduKE9iamVjdC5jcmVhdGUobnVsbCksIHtcbiAgICBlcnI6IGRlZmF1bHRFcnJvclNlcmlhbGl6ZXJcbiAgfSksXG4gIGZvcm1hdHRlcnM6IE9iamVjdC5hc3NpZ24oT2JqZWN0LmNyZWF0ZShudWxsKSwge1xuICAgIGJpbmRpbmdzIChiaW5kaW5ncykge1xuICAgICAgcmV0dXJuIGJpbmRpbmdzXG4gICAgfSxcbiAgICBsZXZlbCAobGFiZWwsIG51bWJlcikge1xuICAgICAgcmV0dXJuIHsgbGV2ZWw6IG51bWJlciB9XG4gICAgfVxuICB9KSxcbiAgaG9va3M6IHtcbiAgICBsb2dNZXRob2Q6IHVuZGVmaW5lZCxcbiAgICBzdHJlYW1Xcml0ZTogdW5kZWZpbmVkXG4gIH0sXG4gIHRpbWVzdGFtcDogZXBvY2hUaW1lLFxuICBuYW1lOiB1bmRlZmluZWQsXG4gIHJlZGFjdDogbnVsbCxcbiAgY3VzdG9tTGV2ZWxzOiBudWxsLFxuICB1c2VPbmx5Q3VzdG9tTGV2ZWxzOiBmYWxzZSxcbiAgZGVwdGhMaW1pdDogNSxcbiAgZWRnZUxpbWl0OiAxMDBcbn1cblxuY29uc3Qgbm9ybWFsaXplID0gY3JlYXRlQXJnc05vcm1hbGl6ZXIoZGVmYXVsdE9wdGlvbnMpXG5cbmNvbnN0IHNlcmlhbGl6ZXJzID0gT2JqZWN0LmFzc2lnbihPYmplY3QuY3JlYXRlKG51bGwpLCBzdGRTZXJpYWxpemVycylcblxuZnVuY3Rpb24gcGlubyAoLi4uYXJncykge1xuICBjb25zdCBpbnN0YW5jZSA9IHt9XG4gIGNvbnN0IHsgb3B0cywgc3RyZWFtIH0gPSBub3JtYWxpemUoaW5zdGFuY2UsIGNhbGxlcigpLCAuLi5hcmdzKVxuXG4gIGlmIChvcHRzLmxldmVsICYmIHR5cGVvZiBvcHRzLmxldmVsID09PSAnc3RyaW5nJyAmJiBERUZBVUxUX0xFVkVMU1tvcHRzLmxldmVsLnRvTG93ZXJDYXNlKCldICE9PSB1bmRlZmluZWQpIG9wdHMubGV2ZWwgPSBvcHRzLmxldmVsLnRvTG93ZXJDYXNlKClcblxuICBjb25zdCB7XG4gICAgcmVkYWN0LFxuICAgIGNybGYsXG4gICAgc2VyaWFsaXplcnMsXG4gICAgdGltZXN0YW1wLFxuICAgIG1lc3NhZ2VLZXksXG4gICAgZXJyb3JLZXksXG4gICAgbmVzdGVkS2V5LFxuICAgIGJhc2UsXG4gICAgbmFtZSxcbiAgICBsZXZlbCxcbiAgICBjdXN0b21MZXZlbHMsXG4gICAgbGV2ZWxDb21wYXJpc29uLFxuICAgIG1peGluLFxuICAgIG1peGluTWVyZ2VTdHJhdGVneSxcbiAgICB1c2VPbmx5Q3VzdG9tTGV2ZWxzLFxuICAgIGZvcm1hdHRlcnMsXG4gICAgaG9va3MsXG4gICAgZGVwdGhMaW1pdCxcbiAgICBlZGdlTGltaXQsXG4gICAgb25DaGlsZCxcbiAgICBtc2dQcmVmaXhcbiAgfSA9IG9wdHNcblxuICBjb25zdCBzdHJpbmdpZnlTYWZlID0gY29uZmlndXJlKHtcbiAgICBtYXhpbXVtRGVwdGg6IGRlcHRoTGltaXQsXG4gICAgbWF4aW11bUJyZWFkdGg6IGVkZ2VMaW1pdFxuICB9KVxuXG4gIGNvbnN0IGFsbEZvcm1hdHRlcnMgPSBidWlsZEZvcm1hdHRlcnMoXG4gICAgZm9ybWF0dGVycy5sZXZlbCxcbiAgICBmb3JtYXR0ZXJzLmJpbmRpbmdzLFxuICAgIGZvcm1hdHRlcnMubG9nXG4gIClcblxuICBjb25zdCBzdHJpbmdpZnlGbiA9IHN0cmluZ2lmeS5iaW5kKHtcbiAgICBbc3RyaW5naWZ5U2FmZVN5bV06IHN0cmluZ2lmeVNhZmVcbiAgfSlcbiAgY29uc3Qgc3RyaW5naWZpZXJzID0gcmVkYWN0ID8gcmVkYWN0aW9uKHJlZGFjdCwgc3RyaW5naWZ5Rm4pIDoge31cbiAgY29uc3QgZm9ybWF0T3B0cyA9IHJlZGFjdFxuICAgID8geyBzdHJpbmdpZnk6IHN0cmluZ2lmaWVyc1tyZWRhY3RGbXRTeW1dIH1cbiAgICA6IHsgc3RyaW5naWZ5OiBzdHJpbmdpZnlGbiB9XG4gIGNvbnN0IGVuZCA9ICd9JyArIChjcmxmID8gJ1xcclxcbicgOiAnXFxuJylcbiAgY29uc3QgY29yZUNoaW5kaW5ncyA9IGFzQ2hpbmRpbmdzLmJpbmQobnVsbCwge1xuICAgIFtjaGluZGluZ3NTeW1dOiAnJyxcbiAgICBbc2VyaWFsaXplcnNTeW1dOiBzZXJpYWxpemVycyxcbiAgICBbc3RyaW5naWZpZXJzU3ltXTogc3RyaW5naWZpZXJzLFxuICAgIFtzdHJpbmdpZnlTeW1dOiBzdHJpbmdpZnksXG4gICAgW3N0cmluZ2lmeVNhZmVTeW1dOiBzdHJpbmdpZnlTYWZlLFxuICAgIFtmb3JtYXR0ZXJzU3ltXTogYWxsRm9ybWF0dGVyc1xuICB9KVxuXG4gIGxldCBjaGluZGluZ3MgPSAnJ1xuICBpZiAoYmFzZSAhPT0gbnVsbCkge1xuICAgIGlmIChuYW1lID09PSB1bmRlZmluZWQpIHtcbiAgICAgIGNoaW5kaW5ncyA9IGNvcmVDaGluZGluZ3MoYmFzZSlcbiAgICB9IGVsc2Uge1xuICAgICAgY2hpbmRpbmdzID0gY29yZUNoaW5kaW5ncyhPYmplY3QuYXNzaWduKHt9LCBiYXNlLCB7IG5hbWUgfSkpXG4gICAgfVxuICB9XG5cbiAgY29uc3QgdGltZSA9ICh0aW1lc3RhbXAgaW5zdGFuY2VvZiBGdW5jdGlvbilcbiAgICA/IHRpbWVzdGFtcFxuICAgIDogKHRpbWVzdGFtcCA/IGVwb2NoVGltZSA6IG51bGxUaW1lKVxuICBjb25zdCB0aW1lU2xpY2VJbmRleCA9IHRpbWUoKS5pbmRleE9mKCc6JykgKyAxXG5cbiAgaWYgKHVzZU9ubHlDdXN0b21MZXZlbHMgJiYgIWN1c3RvbUxldmVscykgdGhyb3cgRXJyb3IoJ2N1c3RvbUxldmVscyBpcyByZXF1aXJlZCBpZiB1c2VPbmx5Q3VzdG9tTGV2ZWxzIGlzIHNldCB0cnVlJylcbiAgaWYgKG1peGluICYmIHR5cGVvZiBtaXhpbiAhPT0gJ2Z1bmN0aW9uJykgdGhyb3cgRXJyb3IoYFVua25vd24gbWl4aW4gdHlwZSBcIiR7dHlwZW9mIG1peGlufVwiIC0gZXhwZWN0ZWQgXCJmdW5jdGlvblwiYClcbiAgaWYgKG1zZ1ByZWZpeCAmJiB0eXBlb2YgbXNnUHJlZml4ICE9PSAnc3RyaW5nJykgdGhyb3cgRXJyb3IoYFVua25vd24gbXNnUHJlZml4IHR5cGUgXCIke3R5cGVvZiBtc2dQcmVmaXh9XCIgLSBleHBlY3RlZCBcInN0cmluZ1wiYClcblxuICBhc3NlcnREZWZhdWx0TGV2ZWxGb3VuZChsZXZlbCwgY3VzdG9tTGV2ZWxzLCB1c2VPbmx5Q3VzdG9tTGV2ZWxzKVxuICBjb25zdCBsZXZlbHMgPSBtYXBwaW5ncyhjdXN0b21MZXZlbHMsIHVzZU9ubHlDdXN0b21MZXZlbHMpXG5cbiAgaWYgKHR5cGVvZiBzdHJlYW0uZW1pdCA9PT0gJ2Z1bmN0aW9uJykge1xuICAgIHN0cmVhbS5lbWl0KCdtZXNzYWdlJywgeyBjb2RlOiAnUElOT19DT05GSUcnLCBjb25maWc6IHsgbGV2ZWxzLCBtZXNzYWdlS2V5LCBlcnJvcktleSB9IH0pXG4gIH1cblxuICBhc3NlcnRMZXZlbENvbXBhcmlzb24obGV2ZWxDb21wYXJpc29uKVxuICBjb25zdCBsZXZlbENvbXBGdW5jID0gZ2VuTGV2ZWxDb21wYXJpc29uKGxldmVsQ29tcGFyaXNvbilcblxuICBPYmplY3QuYXNzaWduKGluc3RhbmNlLCB7XG4gICAgbGV2ZWxzLFxuICAgIFtsZXZlbENvbXBTeW1dOiBsZXZlbENvbXBGdW5jLFxuICAgIFt1c2VPbmx5Q3VzdG9tTGV2ZWxzU3ltXTogdXNlT25seUN1c3RvbUxldmVscyxcbiAgICBbc3RyZWFtU3ltXTogc3RyZWFtLFxuICAgIFt0aW1lU3ltXTogdGltZSxcbiAgICBbdGltZVNsaWNlSW5kZXhTeW1dOiB0aW1lU2xpY2VJbmRleCxcbiAgICBbc3RyaW5naWZ5U3ltXTogc3RyaW5naWZ5LFxuICAgIFtzdHJpbmdpZnlTYWZlU3ltXTogc3RyaW5naWZ5U2FmZSxcbiAgICBbc3RyaW5naWZpZXJzU3ltXTogc3RyaW5naWZpZXJzLFxuICAgIFtlbmRTeW1dOiBlbmQsXG4gICAgW2Zvcm1hdE9wdHNTeW1dOiBmb3JtYXRPcHRzLFxuICAgIFttZXNzYWdlS2V5U3ltXTogbWVzc2FnZUtleSxcbiAgICBbZXJyb3JLZXlTeW1dOiBlcnJvcktleSxcbiAgICBbbmVzdGVkS2V5U3ltXTogbmVzdGVkS2V5LFxuICAgIC8vIHByb3RlY3QgYWdhaW5zdCBpbmplY3Rpb25cbiAgICBbbmVzdGVkS2V5U3RyU3ltXTogbmVzdGVkS2V5ID8gYCwke0pTT04uc3RyaW5naWZ5KG5lc3RlZEtleSl9OntgIDogJycsXG4gICAgW3NlcmlhbGl6ZXJzU3ltXTogc2VyaWFsaXplcnMsXG4gICAgW21peGluU3ltXTogbWl4aW4sXG4gICAgW21peGluTWVyZ2VTdHJhdGVneVN5bV06IG1peGluTWVyZ2VTdHJhdGVneSxcbiAgICBbY2hpbmRpbmdzU3ltXTogY2hpbmRpbmdzLFxuICAgIFtmb3JtYXR0ZXJzU3ltXTogYWxsRm9ybWF0dGVycyxcbiAgICBbaG9va3NTeW1dOiBob29rcyxcbiAgICBzaWxlbnQ6IG5vb3AsXG4gICAgb25DaGlsZCxcbiAgICBbbXNnUHJlZml4U3ltXTogbXNnUHJlZml4XG4gIH0pXG5cbiAgT2JqZWN0LnNldFByb3RvdHlwZU9mKGluc3RhbmNlLCBwcm90bygpKVxuXG4gIGdlbkxzQ2FjaGUoaW5zdGFuY2UpXG5cbiAgaW5zdGFuY2Vbc2V0TGV2ZWxTeW1dKGxldmVsKVxuXG4gIHJldHVybiBpbnN0YW5jZVxufVxuXG5tb2R1bGUuZXhwb3J0cyA9IHBpbm9cblxubW9kdWxlLmV4cG9ydHMuZGVzdGluYXRpb24gPSAoZGVzdCA9IHByb2Nlc3Muc3Rkb3V0LmZkKSA9PiB7XG4gIGlmICh0eXBlb2YgZGVzdCA9PT0gJ29iamVjdCcpIHtcbiAgICBkZXN0LmRlc3QgPSBub3JtYWxpemVEZXN0RmlsZURlc2NyaXB0b3IoZGVzdC5kZXN0IHx8IHByb2Nlc3Muc3Rkb3V0LmZkKVxuICAgIHJldHVybiBidWlsZFNhZmVTb25pY0Jvb20oZGVzdClcbiAgfSBlbHNlIHtcbiAgICByZXR1cm4gYnVpbGRTYWZlU29uaWNCb29tKHsgZGVzdDogbm9ybWFsaXplRGVzdEZpbGVEZXNjcmlwdG9yKGRlc3QpLCBtaW5MZW5ndGg6IDAgfSlcbiAgfVxufVxuXG5tb2R1bGUuZXhwb3J0cy50cmFuc3BvcnQgPSByZXF1aXJlKCcuL2xpYi90cmFuc3BvcnQnKVxubW9kdWxlLmV4cG9ydHMubXVsdGlzdHJlYW0gPSByZXF1aXJlKCcuL2xpYi9tdWx0aXN0cmVhbScpXG5cbm1vZHVsZS5leHBvcnRzLmxldmVscyA9IG1hcHBpbmdzKClcbm1vZHVsZS5leHBvcnRzLnN0ZFNlcmlhbGl6ZXJzID0gc2VyaWFsaXplcnNcbm1vZHVsZS5leHBvcnRzLnN0ZFRpbWVGdW5jdGlvbnMgPSBPYmplY3QuYXNzaWduKHt9LCB0aW1lKVxubW9kdWxlLmV4cG9ydHMuc3ltYm9scyA9IHN5bWJvbHNcbm1vZHVsZS5leHBvcnRzLnZlcnNpb24gPSB2ZXJzaW9uXG5cbi8vIEVuYWJsZXMgZGVmYXVsdCBhbmQgbmFtZSBleHBvcnQgd2l0aCBUeXBlU2NyaXB0IGFuZCBCYWJlbFxubW9kdWxlLmV4cG9ydHMuZGVmYXVsdCA9IHBpbm9cbm1vZHVsZS5leHBvcnRzLnBpbm8gPSBwaW5vXG4iXSwibmFtZXMiOlsib3MiLCJyZXF1aXJlIiwic3RkU2VyaWFsaXplcnMiLCJjYWxsZXIiLCJyZWRhY3Rpb24iLCJ0aW1lIiwicHJvdG8iLCJzeW1ib2xzIiwiY29uZmlndXJlIiwiYXNzZXJ0RGVmYXVsdExldmVsRm91bmQiLCJtYXBwaW5ncyIsImdlbkxzQ2FjaGUiLCJnZW5MZXZlbENvbXBhcmlzb24iLCJhc3NlcnRMZXZlbENvbXBhcmlzb24iLCJERUZBVUxUX0xFVkVMUyIsIlNPUlRJTkdfT1JERVIiLCJjcmVhdGVBcmdzTm9ybWFsaXplciIsImFzQ2hpbmRpbmdzIiwiYnVpbGRTYWZlU29uaWNCb29tIiwiYnVpbGRGb3JtYXR0ZXJzIiwic3RyaW5naWZ5Iiwibm9ybWFsaXplRGVzdEZpbGVEZXNjcmlwdG9yIiwibm9vcCIsInZlcnNpb24iLCJjaGluZGluZ3NTeW0iLCJyZWRhY3RGbXRTeW0iLCJzZXJpYWxpemVyc1N5bSIsInRpbWVTeW0iLCJ0aW1lU2xpY2VJbmRleFN5bSIsInN0cmVhbVN5bSIsInN0cmluZ2lmeVN5bSIsInN0cmluZ2lmeVNhZmVTeW0iLCJzdHJpbmdpZmllcnNTeW0iLCJzZXRMZXZlbFN5bSIsImVuZFN5bSIsImZvcm1hdE9wdHNTeW0iLCJtZXNzYWdlS2V5U3ltIiwiZXJyb3JLZXlTeW0iLCJuZXN0ZWRLZXlTeW0iLCJtaXhpblN5bSIsImxldmVsQ29tcFN5bSIsInVzZU9ubHlDdXN0b21MZXZlbHNTeW0iLCJmb3JtYXR0ZXJzU3ltIiwiaG9va3NTeW0iLCJuZXN0ZWRLZXlTdHJTeW0iLCJtaXhpbk1lcmdlU3RyYXRlZ3lTeW0iLCJtc2dQcmVmaXhTeW0iLCJlcG9jaFRpbWUiLCJudWxsVGltZSIsInBpZCIsInByb2Nlc3MiLCJob3N0bmFtZSIsImRlZmF1bHRFcnJvclNlcmlhbGl6ZXIiLCJlcnIiLCJkZWZhdWx0T3B0aW9ucyIsImxldmVsIiwibGV2ZWxDb21wYXJpc29uIiwiQVNDIiwibGV2ZWxzIiwibWVzc2FnZUtleSIsImVycm9yS2V5IiwibmVzdGVkS2V5IiwiZW5hYmxlZCIsImJhc2UiLCJzZXJpYWxpemVycyIsIk9iamVjdCIsImFzc2lnbiIsImNyZWF0ZSIsImZvcm1hdHRlcnMiLCJiaW5kaW5ncyIsImxhYmVsIiwibnVtYmVyIiwiaG9va3MiLCJsb2dNZXRob2QiLCJ1bmRlZmluZWQiLCJzdHJlYW1Xcml0ZSIsInRpbWVzdGFtcCIsIm5hbWUiLCJyZWRhY3QiLCJjdXN0b21MZXZlbHMiLCJ1c2VPbmx5Q3VzdG9tTGV2ZWxzIiwiZGVwdGhMaW1pdCIsImVkZ2VMaW1pdCIsIm5vcm1hbGl6ZSIsInBpbm8iLCJhcmdzIiwiaW5zdGFuY2UiLCJvcHRzIiwic3RyZWFtIiwidG9Mb3dlckNhc2UiLCJjcmxmIiwibWl4aW4iLCJtaXhpbk1lcmdlU3RyYXRlZ3kiLCJvbkNoaWxkIiwibXNnUHJlZml4Iiwic3RyaW5naWZ5U2FmZSIsIm1heGltdW1EZXB0aCIsIm1heGltdW1CcmVhZHRoIiwiYWxsRm9ybWF0dGVycyIsImxvZyIsInN0cmluZ2lmeUZuIiwiYmluZCIsInN0cmluZ2lmaWVycyIsImZvcm1hdE9wdHMiLCJlbmQiLCJjb3JlQ2hpbmRpbmdzIiwiY2hpbmRpbmdzIiwiRnVuY3Rpb24iLCJ0aW1lU2xpY2VJbmRleCIsImluZGV4T2YiLCJFcnJvciIsImVtaXQiLCJjb2RlIiwiY29uZmlnIiwibGV2ZWxDb21wRnVuYyIsIkpTT04iLCJzaWxlbnQiLCJzZXRQcm90b3R5cGVPZiIsIm1vZHVsZSIsImV4cG9ydHMiLCJkZXN0aW5hdGlvbiIsImRlc3QiLCJzdGRvdXQiLCJmZCIsIm1pbkxlbmd0aCIsInRyYW5zcG9ydCIsIm11bHRpc3RyZWFtIiwic3RkVGltZUZ1bmN0aW9ucyIsImRlZmF1bHQiXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/pino/pino.js\n");

/***/ })

};
;